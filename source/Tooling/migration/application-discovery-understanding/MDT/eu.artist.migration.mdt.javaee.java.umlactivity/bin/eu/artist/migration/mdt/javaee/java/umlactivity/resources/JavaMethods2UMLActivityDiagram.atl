-- @atlcompiler atl2010

-- @nsURI UML=http://www.eclipse.org/uml2/4.0.0/UML
-- @nsURI JAVA=http://www.eclipse.org/MoDisco/Java/0.2.incubation/java

-- ******************************************************************************
-- Copyright (c) 2013 INRIA. 
-- All rights reserved. This program and the accompanying materials 
-- are made available under the terms of the Eclipse Public License v1.0 
-- which accompanies this distribution, and is available at
-- http://www.eclipse.org/legal/epl-v10.html
-- 
-- Contributors: 
-- 	INRIA - Initial implementation
--  authors: Guillaume Doux (guillaume.doux at inria.fr) 
--			 Matthieu Allon (matthieu.allon at gmail.com)
-- Initially developed in the context of ARTIST EU project www.artist-project.eu
-- ******************************************************************************

module JavaMethods2UMLActivityDiagram;

create OUT: UML from IN: JAVA;

uses java2UMLActivityHelpers;

rule JModelRootToUmlModelRoot {
	from 
		jModelRoot : JAVA!Model
	to 
		umlModelRoot : UML!Model (
			name <- 'root model', 			
			packagedElement <- jModelRoot.allAbstractMethodDeclaration
								->including(cd)
								-> append(thisModule.createExternalsModel(jModelRoot))	
		),
		cd	:	UML!Package(
			name <- 'Associated Classifiers',
			packagedElement <- thisModule.allTypes 
									-> union(UML!Dependency.allInstancesFrom('OUT'))
		)
}

---Create 'external' model
unique lazy rule createExternalsModel{
	from 
		jModel : JAVA!Model
	to 
		umlModel : UML!Package(
			name <- 'externals',
			packagedElement <- jModel.getExternalElements
								-> select(elem | elem.oclIsTypeOf(JAVA!Package))
								-> select(elem | elem.isAnExternalPackage)
		)
}

---Package only for the external lib.
rule JPackageToUmlPackage {
	from 
		jPackage : JAVA!Package(
			jPackage.isAnExternalPackage
		)
	to 
		umlPackage : UML!Package (
				name <- jPackage.name, 
				nestedPackage <- jPackage.ownedPackages 
									-> select(elem | elem.isAnExternalPackage),
				packagedElement <- jPackage.ownedElements 
										-> select(c | c.oclIsKindOf(JAVA!ClassDeclaration) 
														or c.oclIsKindOf(JAVA!InterfaceDeclaration) 
														or c.oclIsKindOf(JAVA!EnumDeclaration)
										)
										->collect(c | if c.originalCompilationUnit.oclIsUndefined() 
														then OclUndefined
														else c.originalCompilationUnit.imports
													endif )->flatten()
										->union(
											jPackage.ownedElements	
										),
				nestingPackage <- if (not jPackage.getPackage.oclIsUndefined())then
								 	if (jPackage.getPackage.isAnExternalPackage)then
										jPackage.getPackage
								  	else OclUndefined endif	
								  else OclUndefined endif		
		)		
}

rule createDependency{
	from 
		jImportDec : JAVA!ImportDeclaration
	to 
		umlDependency : UML!Dependency (		
			name <- jImportDec.importedElement.name + '_OF_' + jImportDec.refImmediateComposite().name,
			supplier <- if jImportDec.importedElement.oclIsKindOf(JAVA!VariableDeclarationFragment) then 
							jImportDec.importedElement.originalCompilationUnit.types
						else 
							if jImportDec.importedElement.oclIsKindOf(JAVA!AnnotationTypeDeclaration) then
								jImportDec.importedElement.usagesInImports
									-> collect(usImport | usImport.originalCompilationUnit.types)	
							else 
								if (jImportDec.importedElement.oclIsKindOf(JAVA!EnumConstantDeclaration))then
									jImportDec.importedElement.refImmediateComposite()
								else jImportDec.importedElement endif
							endif
						endif
		)
}

---Block
abstract rule abstractBlock2StructuredActivity{
	from
		block	:	JAVA!Block
	to
		t	:	UML!StructuredActivityNode(
			node <- Sequence{init, block.statements, final} -> flatten()
		),
		
		init	:	UML!InitialNode(),
		final	:	UML!ActivityFinalNode(),
		fcf : UML!ControlFlow(
			name <- 'fromInitLastStatementToFinalNode',
			inStructuredNode <- t,
			target <- final,
			source <- if (block.statements.isEmpty())
							then init
							else block.statements.last()
						endif
		)	
}

rule Block2StructuredActivity extends abstractBlock2StructuredActivity{
	from
		block	:	JAVA!Block	((not block.refImmediateComposite().oclIsKindOf(JAVA!AbstractMethodDeclaration)) 
									and 
								 block.notInInitializerOrFieldOrEnum 
								 	and 
								 block.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Block - ' + block.refImmediateComposite().oclType().toString(),
			inStructuredNode <- block.refImmediateComposite()
		)	
}

rule Block2StructuredActivityForM extends abstractBlock2StructuredActivity{
	from
		block	:	JAVA!Block	(block.refImmediateComposite().oclIsKindOf(JAVA!AbstractMethodDeclaration) 
									and
								block.notInAnnotation
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'structured_'+block.refImmediateComposite(),
			activity <- block.getOwningMethod
		)
}

---(Anonymous)Class
abstract rule abstratASTNodeToClass{
	from
		s : JAVA!ASTNode
	to
		t : UML!Classifier(
			ownedOperation <- s.bodyDeclarations 
								-> select(d | d.oclIsTypeOf(JAVA!MethodDeclaration))
								-> collect(d | thisModule.resolveTemp(d, 'operation')),
			ownedAttribute <- s.bodyDeclarations->select(d | d.oclIsTypeOf(JAVA!FieldDeclaration))
		)
}

rule AnonymousClass extends abstratASTNodeToClass {
	from
		s	:	JAVA!AnonymousClassDeclaration
	to
		t	:	UML!Class(
			name <- if (not s.refImmediateComposite().oclIsKindOf(JAVA!EnumConstantDeclaration)) then
						s.classInstanceCreation.type.type.name
					else 'EnumConstant_' + s.refImmediateComposite().name endif,
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)		
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule Class extends abstratASTNodeToClass {
	from
		s	:	JAVA!ClassDeclaration
	to
		t	:	UML!Class(
			name <- s.name,
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)		
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule enumDeclaration extends abstratASTNodeToClass {
	from
		s	:	JAVA!EnumDeclaration
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported',
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);
	}	
}

rule JInterfaceToUmlInterface extends abstratASTNodeToClass {
	from 
		s : JAVA!InterfaceDeclaration
	to 
		t : UML!Interface (
			name <- s.name,
			clientDependency <- if (not s.originalCompilationUnit.oclIsUndefined()) then
									s.originalCompilationUnit.imports
								else OclUndefined endif
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);
	}		
}

---All statements
abstract rule abstractExpressStatement{
	from
		s : JAVA!Statement(
			s.notInInitializerOrFieldOrEnum 
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite(),
			incoming <- controlFlow
		),		
		controlFlow: UML!ControlFlow(
			name <- 'fromPreviousStructuredActivityNode',
			inStructuredNode <- s.refImmediateComposite(),
			source <- s.getPreceding(),
			target <- t
		),
		
		initialNode : UML!InitialNode(
			inStructuredNode <- t
		),	
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToFirstStructuredActivityNode',
			inStructuredNode <- t,
			source <- initialNode
		),			
		
		finalControlFlow: UML!ControlFlow(
			name <- 'fromLastStructuredActivityNodeToFinalNode',
			inStructuredNode <- t,
			source <- s.getPreceding(),
			target <- final
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

rule instanceVariableUseNotSettNullExpressState extends abstractExpressStatement{
	from
		s : JAVA!ExpressionStatement(
			s.isInstanceVarUse
			and not s.isImplicitThisExpression
			and not s.isSettingNull
			and not s.isClearingList
			and not s.isAddingInList
			and not s.isRemovingInList
		)
	to		
		t	:	UML!StructuredActivityNode(
			name <- 'Instance variable use'
		),		
		
		objectflow : UML!ObjectFlow(
			name <- 'objectToInputPin',
			inStructuredNode <- s.getStatement,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif
		),
		inputPin : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow
		),
		
		readStruct : UML!ReadStructuralFeatureAction(
			inStructuredNode <- s.getStatement,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.getObject.oclIsUndefined())then
									thisModule.createStructFeature(s.expression.getObject)
								  else OclUndefined endif,	
			result <- op
		),	
		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement,
			source <- readStruct,
			target <- s.getOwningMethod.body.statements
						-> select(state | state.oclIsTypeOf(JAVA!ReturnStatement))
						-> first()
						
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow
		)
}

rule instanceVariableUseSettNullExpressState extends abstractExpressStatement{
	from
		s : JAVA!ExpressionStatement(
			s.isInstanceVarUse
			and not s.isImplicitThisExpression
			and s.isSettingNull
		)
	to		
		t	:	UML!StructuredActivityNode(
			name <- 'Instance variable use - set null'
		),		
		
		objectflow : UML!ObjectFlow(
			name <- 'objectToInputPin',
			inStructuredNode <- s.getStatement,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputPin : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow
		),
		
		readStruct : UML!ReadStructuralFeatureAction(
			inStructuredNode <- s.getStatement,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.getObject.oclIsUndefined())then
									thisModule.createStructFeature(s.expression.getObject)
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToClearStructuralFeatureActionInitNode',
			inStructuredNode <- s.getStatement,
			source <- readStruct,
			target <- initialNodeCFA
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow
		),		
		
		initialNodeCFA : UML!InitialNode(),	
		initialControlFlow : UML!ControlFlow(
			name <- 'fromInitNodeToClearStructuralFeatureActionInit',
			inStructuredNode <- t,
			source <- initialNodeCFA,
			target <- clearStructuralFeature
		),
		inputCFA : UML!InputPin (
			name <- 'clearStructuralFeatureActionInput',
			incoming <- initialControlFlow
		),	
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- initialControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
																		-> at(s.expression.arguments
																				-> indexOf(s.expression.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
										thisModule.createStructFeature(express)
									else OclUndefined endif	
								else OclUndefined endif,
			result <- thisModule.createOutputPin(s, 'clearStructuralFeatureActionOutput')		
		),
		finalControlFlow : UML!ControlFlow(
			name <- 'fromClearStructuralFeatureActionToFinalNode',
			inStructuredNode <- t,
			source <- clearStructuralFeature,
			target <- final
		),
		final : UML!ActivityFinalNode()
}

rule implicitThis2IntanceVarUsereadSelf extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.isImplicitThisExpression
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Implicit this'
		),		
		
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite()
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin_1',
			inStructuredNode <- s.getStatement,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputPin : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow
		),
		readStruct : UML!ReadStructuralFeatureAction(
			inStructuredNode <- s.getStatement,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.getObject.oclIsUndefined())then
									thisModule.createStructFeature(s.expression.getObject)
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement,
			source <- readStruct,
			target <- s.getOwningMethod.body.statements
						-> select(state | state.oclIsTypeOf(JAVA!ReturnStatement))
						-> first()
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow
		)
}

rule expressionStatement extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse
			and not s.isClearingList			
			and not s.isAddingInList
			and not s.isRemovingInList
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Not Implicit this, no method used, and no collection used'
		)
}

---Clearing list
rule expressionStatementClearListThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum			
			and s.notInAnnotation 
			and s.isClearingList			
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse			
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - method used'		
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'objectToInputPin',
			inStructuredNode <- s.getStatement,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputPin : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow
		),
		--Getter used
		readStruct : UML!ReadStructuralFeatureAction(
			inStructuredNode <- s.getStatement,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.getObject.oclIsUndefined())then
									thisModule.createStructFeature(s.expression.getObject)
								  else OclUndefined endif,		
			result <- op
		),	
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActionOutput',
			outgoing <- outControlFlow
		),
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement,
			source <- readStruct,
			target <- s.getOwningMethod.body.statements
						-> select(state | state.oclIsTypeOf(JAVA!ReturnStatement))
						-> first()
		),		
		
		inputCFA : UML!InputPin (
			name <- 'clearStructuralFeatureActionInputPin',
			incoming <- outControlFlow
		),			
		--Clear coll.
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- outControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
																		-> at(s.expression.arguments
																				-> indexOf(s.expression.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
										thisModule.createStructFeature(express)
									else OclUndefined endif	
								else OclUndefined endif,
			result <- thisModule.createOutputPin(s, 'clearStructuralFeatureActionOutputPin')		
		)
}

rule expressionStatementClearListInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isClearingList			
			and s.isImplicitThisExpression
			and s.isInstanceVarUse			
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - This, method used'
		),
				
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite()
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin_2',
			inStructuredNode <- s.getStatement,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputPin : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow
		),
		readStruct : UML!ReadStructuralFeatureAction(
			inStructuredNode <- s.getStatement,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.getObject.oclIsUndefined())then
									thisModule.createStructFeature(s.expression.getObject)
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement,
			source <- readStruct,
			target <- s.getOwningMethod.body.statements
						-> select(state | state.oclIsTypeOf(JAVA!ReturnStatement))
						-> first()
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActioOutput'
		),
		
		--Clear coll.
		inputCFA : UML!InputPin (
			name <- 'fromOutControlFlowToClearStructuralFeatureAction',
			incoming <- outControlFlow
		),			
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- outControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
																		-> at(s.expression.arguments
																				-> indexOf(s.expression.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
										thisModule.createStructFeature(express)
									else OclUndefined endif	
								else OclUndefined endif,
			result <- thisModule.createOutputPin(s, 'clearStructuralFeatureActionOutput')		
		)
}

rule expressionStatementClearListImpThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isClearingList
			
			and s.isImplicitThisExpression
			and not s.isInstanceVarUse			
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - Implicit this, no method used'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite()
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin_3',
			inStructuredNode <- s.getStatement,
			target <- inputCFA,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputCFA : UML!InputPin (
			name <- 'objectInput',
			incoming <- objectflow
		),	
		
		--Clear coll.
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- initialControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
																		-> at(s.expression.arguments
																				-> indexOf(s.expression.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
										thisModule.createStructFeature(express)
									else OclUndefined endif	
								else OclUndefined endif,
			result <- op			
		),		
		op	:	UML!OutputPin (
			name <- 'clearStructuralFeatureActionOutput'	
		)
}

rule expressionStatementClearList extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isClearingList
			
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse			
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Clear collection - No method used'
		),
				
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin',
			inStructuredNode <- s.getStatement,
			target <- inputCFA,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputCFA : UML!InputPin (
			name <- 'objectInput',
			incoming <- objectflow
		),	
		
		--Clear coll.
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			name <- 'clear',
			inStructuredNode <- t,			
			outgoing <- finalControlFlow,
			incoming <- initialControlFlow,
			object <- inputCFA,
			structuralFeature <- if (s.expression.method.parameters -> notEmpty())then
									let express : JAVA!Expression = 
										s.expression.method.parameters
																		-> at(s.expression.arguments
																				-> indexOf(s.expression.arguments
																							-> select(arg | arg.oclIsKindOf(JAVA!NullLiteral))
																				)+1
																		)
																		.usageInVariableAccess	
																		-> first()
									in									
									if (not express.oclIsUndefined()) then
										thisModule.createStructFeature(express)
									else OclUndefined endif	
								else OclUndefined endif,
			result <- op			
		),
		
		op	:	UML!OutputPin (
			name <- 'resultClearStructuralFeatureActionOutput'	
		)
}

---Addition of an element in a list
rule expressionStatementAddListThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum			
			and s.notInAnnotation 
			and s.isAddingInList			
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse				
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - Method used'		
		),
				
		--Getter used
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin_5',
			inStructuredNode <- s.getStatement,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputPin : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow
		),
		readStruct : UML!ReadStructuralFeatureAction(
			inStructuredNode <- s.getStatement,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.getObject.oclIsUndefined())then
									thisModule.createStructFeature(s.expression.getObject)
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement,
			source <- readStruct,
			target <- s.getOwningMethod.body.statements
						-> select(state | state.oclIsTypeOf(JAVA!ReturnStatement))
						-> first()
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActioOutput',
			outgoing <- outControlFlow
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement,
			target <- objectIP,
			source <- op
		),
		
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <- s.getStatement,
			target <- valueIP,
			source <- if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif
		),
		
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s)
						 else thisModule.createObjectFlowToVSA(s) endif 
		)
}

rule expressionStatementAddListInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isAddingInList			
			and s.isImplicitThisExpression
			and s.isInstanceVarUse		
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - This, Method invocation'
		),
				
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite()
		),
		
		objectflow : UML!ObjectFlow(
			name <- 'fromObjectToInputPin_6',
			inStructuredNode <- s.getStatement,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputPin : UML!InputPin(
			name <- 'readStructuralFeatureActioInput',
			incoming <- objectflow
		),
		readStruct : UML!ReadStructuralFeatureAction(
			inStructuredNode <- s.getStatement,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.getObject.oclIsUndefined())then
									thisModule.createStructFeature(s.expression.getObject)
								  else OclUndefined endif,		
			result <- op
		),		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement,
			source <- readStruct,
			target <- s.getOwningMethod.body.statements
						-> select(state | state.oclIsTypeOf(JAVA!ReturnStatement))
						-> first()
		),		
		op : UML!OutputPin(
			name <- 'readStructuralFeatureActioOutput',
			outgoing <- outControlFlow
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement,
			target <- objectIP,
			source <- op
		),
		
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <- s.getStatement,
			target <- valueIP,
			source <- 	if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif
		),
		
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s)
						 else thisModule.createObjectFlowToVSA(s) endif 
		)
}

rule expressionStatementAddListImpThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isAddingInList			
			and s.isImplicitThisExpression
			and not s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - Implicit this, no Method invocation'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite()
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement,
			target <- objectIP,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <- s.getStatement,
			target <- valueIP,
			source <- if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif
		),
		
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s)
						 else thisModule.createObjectFlowToVSA(s) endif 
		)
}

rule expressionStatementAddList extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isAddingInList			
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Addition of an element in collection - no Method invocation'
		),
		
		--Add in coll.
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			inStructuredNode <- t,
			object <- objectIP,
			value <- valueIP,
			insertAt <- insertAtIP,
			isReplaceAll <- false
		),
		
		objectIP : UML!InputPin(
			name <- 'object',
			incoming <- objectInput
		),
		objectInput : UML!ObjectFlow(
			name <- 'fromObjectToObjectIP',
			inStructuredNode <- s.getStatement,
			target <- objectIP,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		
		valueIP : UML!InputPin(
			name <- 'value',
			incoming <- valueInput
		),
		valueInput : UML!ObjectFlow(
			name <- 'fromValueToValueIP',
			inStructuredNode <- s.getStatement,
			target <- valueIP,
			source <- if (not s.expression.getLastListMethodArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getLastListMethodArgument
					  else OclUndefined endif
		),
		
		insertAtIP : UML!InputPin(
			name <- 'insertAt',
			lower <-	if (s.isAnEmptyCollection) then
							0
						else 1 endif,
			upper <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
						1
					 else -1 endif,
			incoming <- if (s.expression.arguments -> size() = 2 and not s.isAnEmptyCollection) then
							thisModule.createObjectFlowToNode(s)
						 else thisModule.createObjectFlowToVSA(s) endif 
		)
}

---Removing an element in a collection
rule expressionStatementRemoveListThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum			
			and s.notInAnnotation 
			and s.isRemovingInList		
			and not s.isImplicitThisExpression
			and s.isInstanceVarUse				
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - Method used'		
		),
				
		--Getter used
		objectflow : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureAction',
			inStructuredNode <- s.getStatement,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputPin : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow
		),		
		
		readStruct : UML!ReadStructuralFeatureAction(
			inStructuredNode <- s.getStatement,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.getObject.oclIsUndefined())then
									thisModule.createStructFeature(s.expression.getObject)
								  else OclUndefined endif,	
			result <- op
		),		
		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement,
			source <- readStruct,
			target <- s.getOwningMethod.body.statements
						-> select(state | state.oclIsTypeOf(JAVA!ReturnStatement))
						-> first()
		),		
		op : UML!OutputPin(
			name <- 'controlOutput',
			outgoing <- outControlFlow
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- op,
			target <- forkNodeObject,
			inStructuredNode <- t
		),
		
		forkNodeObject : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNodeObject,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNodeObject,
			target <- inPinReadSF,
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF
		),
		
		readSF : UML!ReadStructuralFeatureAction(
			object <- inPinReadSF,			
			result <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			inStructuredNode <- t
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- thisModule.createOutputPin('readStructuralFeatureActionOutput'),
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior'
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t
		),
		
		callBCollGet : UML!CallBehaviorAction(
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},			
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t	
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction'
		),
		
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.expression.getRemoveCollectionArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,						
			target <- forkNodeIndex,
			inStructuredNode <- t
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t	
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1
		),
		
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t	
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1
		)
}

rule expressionStatementRemoveListInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isRemovingInList			
			and s.isImplicitThisExpression
			and s.isInstanceVarUse		
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - This, Method invocation'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite()
		),
		
		--Getter used
		objectflow : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureAction',
			inStructuredNode <- s.getStatement,
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputPin : UML!InputPin(
			name <- 'objectInput',
			incoming <- objectflow
		),		
		
		readStruct : UML!ReadStructuralFeatureAction(
			inStructuredNode <- s.getStatement,
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.getObject.oclIsUndefined())then
									thisModule.createStructFeature(s.expression.getObject)
								  else OclUndefined endif,	
			result <- op
		),		
		
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.getStatement,
			source <- readStruct,
			target <- s.getOwningMethod.body.statements
						-> select(state | state.oclIsTypeOf(JAVA!ReturnStatement))
						-> first()
		),		
		op : UML!OutputPin(
			name <- 'controlOutput',
			outgoing <- outControlFlow
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- op,
			target <- forkNodeObject,
			inStructuredNode <- t
		),
		
		forkNodeObject : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNodeObject,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNodeObject,
			target <- inPinReadSF,
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF
		),
		
		readSF : UML!ReadStructuralFeatureAction(
			object <- inPinReadSF,			
			result <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			inStructuredNode <- t
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior'
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t
		),
		
		callBCollGet : UML!CallBehaviorAction(
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t	
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction'
		),
		
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.getRemoveCollectionArgument.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,					
			target <- forkNodeIndex,
			inStructuredNode <- t
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t	
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1
		),
		
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t	
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1
		)
}

rule expressionStatementRemoveListImpThisInstanVar extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isRemovingInList			
			and s.isImplicitThisExpression
			and not s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - Implicit this, no Method invocation'
		),
				
		--Implicit this
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite()
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- forkNodeObject,
			inStructuredNode <- t
		),
		
		forkNodeObject : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNodeObject,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNodeObject,
			target <- inPinReadSF,
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF
		),
		
		readSF : UML!ReadStructuralFeatureAction(
			object <- inPinReadSF,			
			result <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			inStructuredNode <- t
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- thisModule.createOutputPin(s, 'readStructuralFeatureActionOutput'),
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior'
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t
		),
		
		callBCollGet : UML!CallBehaviorAction(
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t	
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction'
		),
		
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,
			target <- forkNodeIndex,
			inStructuredNode <- t
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t	
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1
		),
		
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t	
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1
		)
}

rule expressionStatementRemoveList extends abstractExpressStatement{
	from
		s	:	JAVA!ExpressionStatement (
			s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation 
			and s.isRemovingInList			
			and not s.isImplicitThisExpression
			and not s.isInstanceVarUse	
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Removing an element in a collection - no Method invocation'
		),
		
		--Removing an element in coll.
		inObjflowExpress : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActionOutputToForkNode',
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- forkNodeObject,
			inStructuredNode <- t
		),
		
		forkNodeObject : UML!ForkNode(
			name <- 'ReadStructuralFeatureActionOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowExpress,			
			outgoing <- Sequence{outObjRemSFVA, outObjReadSF},
			inStructuredNode <- t
		),
		
		outObjRemSFVA : UML!ObjectFlow(
			name <- 'fromForkNodeToRemoveStructuralFeatureValueActionInput',
			source <- forkNodeObject,
			target <- inPinRemSFVAObject,
			inStructuredNode <- t
		),
		inPinRemSFVAObject : UML!InputPin(
			name <- 'objectInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjRemSFVA
		),
		remSFVA : UML!RemoveStructuralFeatureValueAction(
			object <- inPinRemSFVAObject,
			value <- inPinRemSFVAValue,
			removeAt <- inPinRemSFVARemoveAt,
			isRemoveDuplicates <- false,
			inStructuredNode <- t
		),
		
		inObjReadSF : UML!ObjectFlow(
			name <- 'fromForkNodeToReadStructuralFeatureActionInput',
			source <- forkNodeObject,
			target <- inPinReadSF,
			inStructuredNode <- t
		),
		inPinReadSF : UML!InputPin(
			name <- 'objectInputOfReadStructuralFeatureAction',
			incoming <- inObjReadSF
		),
		
		readSF : UML!ReadStructuralFeatureAction(
			object <- inPinReadSF,			
			result <- op,
			inStructuredNode <- t
		),
		op : UML!OutputPin(
			name <- 'ReadStructuralFeatureActionOutput'
		),
		outObjReadSF : UML!ObjectFlow(
			name <- 'fromReadStructuralFeatureActiontoCallBehavior',
			source <- op,
			target <- inPinReadSFCBCollGet,
			inStructuredNode <- t
		),
		inPinReadSFCBCollGet : UML!InputPin(
			name <- 'listInputOfCallBehavior'
		),
		contFlowRSFCBCollGet : UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToCallBehavior',
			source <- readSF,
			target <- callBCollGet,
			inStructuredNode <- t
		),
		
		callBCollGet : UML!CallBehaviorAction(
			argument <- Sequence{inPinReadSFCBCollGet,inPinIndCBCollGet},
			result <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s,'resultOutputOfCallBehavior') endif,
			inStructuredNode <- t,
			behavior <- thisModule.createListGetFumlLib(s)
		),
		outObjCallBCollGet : UML!ObjectFlow(
			name <- 'fromCallBehaviorResultToRemoveStructuralFeatureValueActionValue',
			source <- 	if (s.expression.isIndexLessOne) then
							OclUndefined
						else thisModule.createOutputPin(s, 'resultOutputOfCallBehavior') endif,
			target <- inPinRemSFVAValue,
			inStructuredNode <- t	
		),
		inPinRemSFVAValue : UML!InputPin(
			name <- 'valueInputOfRemoveStructuralFeatureValueAction'
		),
		
		inObjflowIndexExpress : UML!ObjectFlow(
			name <- 'fromExpressionToForkNodeIndex',
			source <- if (not s.expression.getRemoveCollectionArgument.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression.getRemoveCollectionArgument
					  else OclUndefined endif,
			target <- forkNodeIndex,
			inStructuredNode <- t
		),
		forkNodeIndex : UML!ForkNode(
			name <- 'fromIndexToCallBehaviorOrRemoveStructuralFeatureValueAction',
			incoming <- inObjflowIndexExpress,			
			outgoing <- Sequence{outObjIndCBCollGet, outObjIndRemSFVA},
			inStructuredNode <- t
		),
		
		outObjIndCBCollGet : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToCallBehavior',
			source <- forkNodeIndex,
			target <- callBCollGet,
			inStructuredNode <- t	
		),
		inPinIndCBCollGet : UML!InputPin(
			name <- 'indexInputOfCallBehavior',
			incoming <- outObjIndCBCollGet,
			lower <- 1
		),
		
		outObjIndRemSFVA : UML!ObjectFlow(
			name <- 'objectfromForkNodeIndexToRemoveStructuralFeatureValueAction',
			source <- forkNodeIndex,
			target <- remSFVA,
			inStructuredNode <- t	
		),
		inPinRemSFVARemoveAt : UML!InputPin(
			name <- 'removeAtInputOfRemoveStructuralFeatureValueAction',
			incoming <- outObjIndRemSFVA,
			lower <- 1
		)
}

abstract rule returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement 
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.getStatement,
			name <- s.getOwningMethod.name +' return',
			incoming <- ob	
		),
		ob : UML!ObjectFlow(
			name <- 'fromExpressionToActivityParameterNode',
			inStructuredNode <- s.getStatement,
			source <- if (s.expression.oclIsTypeOf(JAVA!SingleVariableAccess)) then 
							thisModule.resolveTemp(s.expression.variable, 'apn')
						else thisModule.resolveTemp(s.expression, 'op') endif,
			target <- apn
		),	
		
		--(Implicit)This
		read	:	UML!ReadSelfAction (			
			result <- thisModule.resolveTemp(s.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite()
		),
		
		apn	:	UML!ActivityParameterNode(
			name <- 'return',
			type <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ParameterizedType)) then
						s.getOwningMethod.returnType.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
							s.getOwningMethod.returnType.type.elementType.type.excludeUnresolvedTypeDec
						else
							s.getOwningMethod.returnType.type.excludeUnresolvedTypeDec
						endif
					endif,
			parameter <- paramAct,
			incoming <- ob
		),
		paramAct	:	UML!Parameter(
			name <- 'return',
			direction <- #return,
			type <- if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ParameterizedType)) then
						s.getOwningMethod.returnType.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (s.getOwningMethod.returnType.type.oclIsKindOf(JAVA!ArrayType)) then
							s.getOwningMethod.returnType.type.elementType.type.excludeUnresolvedTypeDec
						else
							s.getOwningMethod.returnType.type.excludeUnresolvedTypeDec
						endif
					endif
					
		),
	    op : UML!OutputPin (
			name <- 'resultOutput'	
		)
}

rule returnStatementNoMethodCall extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			not s.expression.oclIsKindOf(JAVA!MethodInvocation)	
		)
	to
		t	:	UML!StructuredActivityNode(),
				
		obToReadStruct : UML!ObjectFlow(
			name <- 'fromExpressionToReadStructuralFeatureActionInput',
			inStructuredNode <- s.refImmediateComposite(),
			target <- inputPin,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif	
		),
		inputPin : UML!InputPin(
			name <- 'readInput'
		),
		readStruct : UML!ReadStructuralFeatureAction(
			inStructuredNode <- s.refImmediateComposite(),
			outgoing <- outControlFlow,
			object <- inputPin,
			structuralFeature <- if (not s.expression.oclIsUndefined())then --When return 'null', empty 'expression' reference
									if(not s.expression.getObject.oclIsUndefined())then
										thisModule.createStructFeature(s.expression.getObject)
									else OclUndefined endif	
								  else OclUndefined endif,
			result <- op,
			incoming <- obToReadStruct
		),			
		outControlFlow	:	UML!ControlFlow(
			name <- 'fromReadStructuralFeatureActionToReturn',
			inStructuredNode <- s.refImmediateComposite(),
			source <- readStruct,
			target <- s.getOwningMethod.body.statements
						-> select(state | state.oclIsTypeOf(JAVA!ReturnStatement))
						-> first()
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

rule returnStatementMethodInvocation extends returnStatementGlobal{
	from
		s	:	JAVA!ReturnStatement (
			s.expression.oclIsKindOf(JAVA!MethodInvocation)	
		)
	to
		t	:	UML!StructuredActivityNode(),
		
		--Calling method
		inputPin	:	UML!InputPin (
			name <- 'targetInput'
		),
		of2CallOperAct : UML!ObjectFlow (
			name <- 'fromMethodInvocationOutPut',
			source <- thisModule.resolveTemp(s.expression.expression, 'op'),
			inStructuredNode <- s.refImmediateComposite(),
			target <- inputPin
		),
		co	:	UML!CallOperationAction(
			name <- if (not s.expression.method.oclIsUndefined()) then
						 s.expression.method.name
					else 'Undefined' endif,
			operation <- thisModule.resolveTemp(s.expression.method, 'operation'),
			inStructuredNode <- s.refImmediateComposite(),
			argument <- s.expression.arguments->collect(a | 	if a.isPrimitiveType then
																	thisModule.createArgument(a)
																else
																	thisModule.createArgumentNotPrimitiv(a)
																endif	
			),
			result <- op,
			incoming <- of2CallOperAct,
			target <- inputPin
		)
	do{
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(s.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(s.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

abstract rule abstractConditionnalAndBranchingStatement{
	from
		s : JAVA!Statement(s.oclIsTypeOf(JAVA!AssertStatement)
							or s.oclIsTypeOf(JAVA!SwitchStatement)	
							or s.oclIsTypeOf(JAVA!ContinueStatement)	
							or s.oclIsTypeOf(JAVA!EmptyStatement)	
							or s.oclIsTypeOf(JAVA!SynchronizedStatement)	
							or s.oclIsTypeOf(JAVA!ThrowStatement)	
							or s.oclIsTypeOf(JAVA!BreakStatement)	
							or s.oclIsTypeOf(JAVA!SwitchCase)	
		)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite()
		),
		pre	:	UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode,
			source <- s.getPreceding(),
			target <- t
		)
}

rule assertStatement extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!AssertStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(		
			name <- 'AssertStatement-Incomplete'
		)
}


rule switchStatement extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!SwitchStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'SwitchStatement-Incomplete'
		)
}

rule continue extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!ContinueStatement (s.notInInitializerOrFieldOrEnum and	s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'continue'
		)
}

rule empty extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!EmptyStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'empty'
		)
}

rule synchro extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!SynchronizedStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Synchronized-incomplete'
		)
}

rule throw extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!ThrowStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'throw'
		),
		pos	:	UML!ControlFlow(
			name <- 'fromStructuredNodeToFinalNode',  
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode,
			source <- t,
			target <- thisModule.resolveTemp(s.getOwningMethod.body, 'final')
		),
		
		initialNode : UML!InitialNode(
			inStructuredNode <- t
		),
		initialControlFlow: UML!ControlFlow(
			name <- 'fromPrecedingNodeToInitialNode',
			inStructuredNode <- t,
			source <- s.getPreceding(),
			target <- initialNode
		),
		
		finalControlFlow: UML!ControlFlow(
			name <- 'fromPrecedingNodeToFinalNode',
			inStructuredNode <- t,
			source <- s.getPreceding(),
			target <- final
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

rule break extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!BreakStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!OpaqueAction(
			name <- 'break'
		),
		pos	:	UML!ControlFlow(
			name <- 'fromOpaqueActionToFinalNode', 
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode,
			source <- t,
			target <- thisModule.resolveTemp(s.refImmediateComposite(), 'fin')
		)
}

rule switchCase extends abstractConditionnalAndBranchingStatement{
	from
		s	:	JAVA!SwitchCase (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'SwitchCase-Incomplete'
		)
}

abstract rule abstractLoopAndTryStatement{
	from
		s : JAVA!Statement(s.oclIsTypeOf(JAVA!TryStatement)
							or s.oclIsTypeOf(JAVA!ForStatement)
							or s.oclIsTypeOf(JAVA!EnhancedForStatement)
							or s.oclIsTypeOf(JAVA!WhileStatement)
							or s.oclIsTypeOf(JAVA!DoStatement)
		)
	to
		t	:	UML!StructuredActivityNode(
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode
		),
		pre	:	UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inActivity <- 	s.getContainerActivity,
			inStructuredNode <- s.getContainerStructuredNode,
			source <- s.getPreceding(),
			target <- t
		)
}

rule forStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!ForStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'for'
		),
		
		td	:	UML!ObjectFlow(
			name <- 'fromExpressionToDecisionNode',
			inStructuredNode <- t,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- dec,
			name <- '<<decisionInputFlow>>'
		),
				
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitNodeToInitializer',
			inStructuredNode <- t,
			source <- ini,
			target <- s.initializers->first()						
		),
		
		jn	:	UML!JoinNode(
			inStructuredNode <- t
		),
		dec	:	UML!DecisionNode(
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),
		id2	:	UML!ControlFlow(
			name <- 'fromInitializerToJoinNode',
			inStructuredNode <- t,
			source <- if (not s.initializers->first().oclIsKindOf(JAVA!TypeLiteral)) then
						s.initializers->first()
					  else OclUndefined endif,
			target <- jn
		),		
		id3	:	UML!ControlFlow(
			name <- 'fromJoinNodeToDecisionNode',
			inStructuredNode <- t,
			source <- jn,
			target <- dec
		),		
		
		fc	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToBody',
			inStructuredNode <- t,
			source <- dec,
			target <- s.body,
			guard <- uvt
		),
		ef	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToFinalNode',
			inStructuredNode <- t,
			source <- dec,
			target <- final,
			guard <- uvf
		),
		
		uvt	:	UML!LiteralBoolean(
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			value <- false
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		),
		
		id4	:	UML!ControlFlow(
			name <- 'fromBodyToUpdater',
			inStructuredNode <- t,
			source <- s.body,
			target <- s.updaters->first()						
		),
		id5	:	UML!ControlFlow(
			name <- 'fromUpdaterToJoinNode',
			inStructuredNode <- t,
			source <- if (not s.updaters->first().oclIsKindOf(JAVA!TypeLiteral)) then
						s.updaters->first()
					  else OclUndefined endif,
			target <- jn
		)
}

rule enhancedForStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!EnhancedForStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to		
		t	:	UML!StructuredActivityNode(
			name <- 'foreach'
		),
		
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitNodeToActivityNode', 
			inStructuredNode <- t,
			source <- ini,
			target <- s.expression.getActivityNode()						
		),
		
		of	:	UML!ObjectFlow(
			name <- 'fromActivityNodeToExpansionRegion',
			inStructuredNode <- t,
			source <- s.expression.getActivityNode(),
			target <- er
		),
		er	:	UML!ExpansionRegion(
			inStructuredNode <- t
		),
		
		ier	:	UML!InitialNode(
			inStructuredNode <- er
		),
		fe1	:	UML!ControlFlow(
			name <- 'fromInitNodeToBody',
			inStructuredNode <- er,
			source <- ier,
			target <- s.body						
		),
		
		fe2	:	UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			inStructuredNode <- er,
			source <- s.body,
			target <- final
		),
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- er
		),
		
		id2	:	UML!ControlFlow(
			name <- 'fromExpansionRegionToFinalNode',
			inStructuredNode <- t,
			source <- er,
			target <- thisModule.createActivityFinalNode(t)
		)
}

rule whileStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!WhileStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'while'
		),
		
		jn	:	UML!JoinNode(
			inStructuredNode <- t
		),
		dec	:	UML!DecisionNode(
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),		
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitialNodeToJoinNode',
			inStructuredNode <- t,
			source <- ini,
			target <- jn
		),
		id2	:	UML!ControlFlow(
			name <- 'fromJoinNodeToDecisionNode',
			inStructuredNode <- t,
			source <- jn,
			target <- dec
		),
		
		td	:	UML!ObjectFlow(
			name <- 'fromExpressionToDecisionNode',
			inStructuredNode <- t,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- dec,
			name <- '<<decisionInputFlow>>'
		),
		
		fc	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToBody',
			inStructuredNode <- t,
			source <- dec,
			target <- s.body,
			guard <- uvt
		),
		
		ef	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToFinalNode',
			inStructuredNode <- t,
			source <- dec,
			target <- final,
			guard <- uvf
		),
		uvt	:	UML!LiteralBoolean(
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			value <- false
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		),
		
		id3	:	UML!ControlFlow(
			name <- 'fromBodyToJoinNode',
			inStructuredNode <- t,
			source <- s.body,
			target <- jn
		)
}

rule doWhileStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!DoStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'doWhile'
		),
		
		jn	:	UML!JoinNode(
			inStructuredNode <- t
		),
		dec	:	UML!DecisionNode(
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		id1	:	UML!ControlFlow(
			name <- 'fromInitialNodeToJoinNode', 
			inStructuredNode <- t,
			source <- ini,
			target <- jn
		),
		id2	:	UML!ControlFlow(
			name <- 'fromJoinNodeToBody',
			inStructuredNode <- t,
			source <- jn,
			target <- s.body
		),
		td	:	UML!ObjectFlow(
			name <- 'fromExpressionToDecisionNode',
			inStructuredNode <- t,
			source <- if (not s.expression.oclIsKindOf(JAVA!TypeLiteral)) then
						s.expression
					  else OclUndefined endif,
			target <- dec,
			name <- '<<decisionInputFlow>>'
		),
		fc	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToJoinNode', 
			inStructuredNode <- t,
			source <- dec,
			target <- jn,
			guard <- uvt
		),
		ef	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToFinalNode', 
			inStructuredNode <- t,
			source <- dec,
			target <- final,
			guard <- uvf
		),
		uvt	:	UML!LiteralBoolean(
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			value <- false
		),
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t
		),
		
		id3	:	UML!ControlFlow(
			name <- 'fromBodyToDecisionNode', 
			inStructuredNode <- t,
			source <- s.body,
			target <- dec
		)
}

rule tryStatement extends abstractLoopAndTryStatement{
	from
		s	:	JAVA!TryStatement (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'try'
		),
		
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		ib	:	UML!ControlFlow(
			name <- 'fromInitialNodeToBody', 
			inStructuredNode <- t,
			source <- ini,
			target <- s.body
		),
		bf	:	UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			inStructuredNode <- t,
			source <- s.body,
			target <- final
		),
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

rule VariableDeclaration {
	from
		s	:	JAVA!VariableDeclarationStatement (	s.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
													and s.notInInitializerOrFieldOrEnum 
													and s.notInAnnotation
		)
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite(),
			name <- 'declare_'+s.fragments->first().name
		),		
		oFToForkNode : UML!ObjectFlow(
			name <- 'declare_'+s.fragments->first().name+'_object_flow_to_fork_node',
			inStructuredNode <- s.refImmediateComposite(),			
			source <- thisModule.resolveTemp(s.fragments -> first().initializer,'op'),
			target <- forkNode
		),	
		forkNode : UML!ForkNode(
			name <- 'declare_'+s.fragments->first().name+'_fork_node',
			inStructuredNode <- s.refImmediateComposite(),
			outgoing <-	s.getOthersUsingIt
							-> collect(otherVDState | thisModule.createObjectFlow(forkNode, otherVDState,
																	otherVDState.getOtherVDSInputPin(s))
							)
							-> flatten()
		),
		
		icf	: UML!ControlFlow(
			name <- 'to_declare_'+s.fragments->first().name,
			inStructuredNode <- s.refImmediateComposite(),
			source <- s.getPreceding(),
			target <- t
		),
		ocf	: UML!ControlFlow(
			name <- 'from_declare_'+s.fragments->first().name,
			inStructuredNode <- s.refImmediateComposite(),
			source <- t,
			target <- s.getNext()
		)		
}

rule ifStatement { --simplifed mapping in case of empty else branch
	from
		s	:	JAVA!IfStatement (s.notInInitializerOrFieldOrEnum)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- s.refImmediateComposite(),
			name <- 'If'
		),
		
		ini	:	UML!InitialNode(
			name <- 'InitialNode',
			inStructuredNode <- t
		),
		inToDecNContFl : UML!ControlFlow(
			name <- 'InitialNode to decisionNode',
			inStructuredNode <- t,
			source <- ini,
			target <- decNode
		),
		td	:	UML!ObjectFlow(
			name <- '<<decisionInputFlow>> - Test expression to DecisionNode',
			inStructuredNode <- t,
			source <- s.expression.getActivityNode(),
			target <- decNode			
		),
		decNode	:	UML!DecisionNode(
			name <- 'DecisionNode - IfStatement',
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),		
		
		truThen	: UML!ControlFlow(
			name <- 'Then(true) - DecisionNode to ThenStatement',
			inStructuredNode <- t,
			source <- decNode,
			target <- s.thenStatement,
			guard <- trueGuard
		),
		trueGuard :	UML!LiteralBoolean(
			value <- true
		),
		
		falElse	: UML!ControlFlow(
			name <- 'Else(false) - DecisionNode to ElseStatement',
			inStructuredNode <- t,
			source <- decNode,
			target <- if s.elseStatement.oclIsUndefined() 
						then thisModule.createEmptyElse(s)
						else s.elseStatement 
					endif,
			guard <- falseGuard
		),		
		falseGuard : UML!LiteralBoolean(
			value <- false
		),
		
		merNode	:	UML!MergeNode(
			name <- 'Merge Then and Else statements',
			inStructuredNode <- t
		),
		t2j	:	UML!ControlFlow(
			name <- 'Then statement to MergeNdoe',
			inStructuredNode <- t,
			source <- s.thenStatement,
			target <- merNode
		),
		e2j	:	UML!ControlFlow(
			name <- 'Else statement to MergeNdoe',
			inStructuredNode <- t,
			source <- if s.elseStatement.oclIsUndefined() 
						then thisModule.createEmptyElse(s)
						else s.elseStatement
					endif,
			target <- merNode
		),
		
		endForkNode	:	UML!ForkNode(
			name <- 'External and End ForkNode',
			inStructuredNode <- s.refImmediateComposite()
		),
		mergToEndFnContFlow	:	UML!ControlFlow(
			name <- 'MergeNode to End ForkNode',
			inStructuredNode <- t,
			source <- merNode,
			target <- endForkNode
		)		
}



rule labelStatement2StructuredActivity {
	from
		s : JAVA!LabeledStatement (
			(not s.refImmediateComposite().oclIsKindOf(JAVA!AbstractMethodDeclaration)) 
			and s.notInInitializerOrFieldOrEnum 
			and s.notInAnnotation
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- s.refImmediateComposite().oclType().toString(),
			inStructuredNode <- if s.oclIsKindOf(JAVA!UnresolvedLabeledStatement)then
									s.getCorrespondingDec.getStatement
								else s.getStatement endif,
			node <- Sequence{init, s.body, final}
						->flatten()						
		),
		init	:	UML!InitialNode(),
		final	:	UML!ActivityFinalNode(),		
		fcf : UML!ControlFlow(
			name <- 'fromInitBodyNodeToFinalNode', 
			inStructuredNode <- t,
			target <- final,
			source <- if (s.body.oclIsUndefined())
							then init
							else 
								if s.oclIsKindOf(JAVA!UnresolvedLabeledStatement)then
									s.getCorrespondingDec.body
								else s.body endif
						endif
		)
}

rule catchClause {
	from
		s	:	JAVA!CatchClause (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'catch ' + if s.exception.type.type.oclIsUndefined() 
									then 'Unknown Exception'
									else s.exception.type.type.name
								endif,
			inStructuredNode <- s.refImmediateComposite()
		),
		
		ini	:	UML!InitialNode(
			inStructuredNode <- t
		),
		ib	:	UML!ControlFlow(
			name <- 'fromInitialNodeToBody',
			inStructuredNode <- t,
			source <- ini,
			target <- s.body
		),
		
		bf	:	UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			inStructuredNode <- t,
			source <- s.body,
			target <- final
		),
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t
		),
		
		tc	:	UML!ControlFlow(
			name <- if s.exception.type.type.oclIsUndefined() 
									then 'Unknown Exception'
									else s.exception.type.type.name
								endif,
			inStructuredNode <- s.refImmediateComposite(),
			source <- s.refImmediateComposite().body,
			target <- t,
			guard <- ivs
		),
		ivs	:	UML!InstanceValue(
			name <- if s.exception.type.type.oclIsUndefined() 
									then 'Unknown Exception'
									else s.exception.type.type.name
								endif,
			type <- s.exception.type.type.excludeUnresolvedTypeDec
		)
		
}

rule classInstanceCreation2CreateObject {
	from
		ci	:	JAVA!ClassInstanceCreation (	ci.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
												and ci.notInInitializerOrFieldOrEnum 
												and ci.notInAnnotation
		)
	to 		
		createObjectAction : UML!CreateObjectAction(
			name <- 'Constructor Invocation of '+ ci.originalCompilationUnit.name,
			classifier <- 	if(ci.type.type.oclIsKindOf(JAVA!ParameterizedType))then
								ci.method.abstractTypeDeclaration.excludeUnresolvedMethodDec
							else ci.type.type.excludeUnresolvedTypeDec endif,
			result <- op
		),		
		op : UML!OutputPin(
			name <- 'Result of constructor invocation of ' + ci.originalCompilationUnit.name,
			type <- if(ci.type.type.oclIsKindOf(JAVA!ParameterizedType))then
						ci.method.abstractTypeDeclaration.excludeUnresolvedMethodDec
					else ci.type.type.excludeUnresolvedTypeDec endif,
			outgoing <- outObjCreateOA
		),
		
		outObjCreateOA : UML!ObjectFlow(
			name <- 'fromOutputConstrucotrInvocationToForkNode',
			activity <- ci.getOwningMethod,
			source <- op,
			target <- forkCreateObj
		),
		forkCreateObj : UML!ForkNode(
			incoming <- outObjCreateOA,
			outgoing <- Sequence{inObjCallOA}
		),
		inObjCallOA : UML!ObjectFlow(
			name <- 'fromforkNodeToCallOperationAction',
			source <- forkCreateObj,
			target <- inputPin
		),
		
		co	:	UML!CallOperationAction(
			name <- ci.method.name,
			operation <- thisModule.resolveTemp(ci.method, 'operation'),
			target <- inputPin,
			argument <- ci.arguments->collect(a | 	if a.isPrimitiveType then
														thisModule.createArgument(a)
													else
														thisModule.createArgumentNotPrimitiv(a)
													endif	
													)
		),
		inputPin : UML!InputPin (
			name <- 'target'
		)
	do{
		thisModule.resolveTemp(ci.getOwningMethod, 'act').ownedNode
			<- thisModule.resolveTemp(ci.getOwningMethod, 'act').ownedNode 
				-> union(Sequence{createObjectAction, forkCreateObj, co});
		thisModule.resolveTemp(ci.getOwningMethod, 'act').edge
			<- thisModule.resolveTemp(ci.getOwningMethod, 'act').edge 
				-> union(Sequence{outObjCreateOA, inObjCallOA});
	}
}

---Convert a java attribut to an Uml field
rule JAttributeToUmlField{
	from 
		jBodyDec : JAVA!FieldDeclaration
	to 
		umlElement : UML!Property (
				name <- jBodyDec.getFieldName, 		
				type <- 	if (jBodyDec.getFieldType.oclIsKindOf(JAVA!ArrayType)) then
									jBodyDec.getFieldType
							else if (jBodyDec.getFieldType.oclIsKindOf(JAVA!TypeParameter)) then
										jBodyDec.getFieldType
								 else 
								 	if (jBodyDec.getFieldType.oclIsKindOf(JAVA!ParameterizedType)) then
										jBodyDec.getFieldType.typeArguments ->first().type.excludeUnresolvedTypeDec
									else jBodyDec.getFieldType endif	
								 endif
							endif,						
				visibility <- jBodyDec.getFieldVisibility
		)
}

abstract rule constructorAndMethod2Activity{
	from
		construcOrMethodDec : JAVA!AbstractMethodDeclaration(
			not construcOrMethodDec.oclIsKindOf(JAVA!UnresolvedMethodDeclaration)	
		)
	to
		act	:	UML!Activity(),
		operation : UML!Operation(
			name <- if (not construcOrMethodDec.oclIsKindOf(JAVA!MethodDeclaration)) then
						'Constructor_'+construcOrMethodDec.getConstructorName
					else 'Method_'+construcOrMethodDec.getMethodName endif,
			method <- act,
			ownedParameter <- construcOrMethodDec.parameters
								-> collect(param |thisModule.Parameters2ActivityParameter(param))
		)
}

rule constructor extends constructorAndMethod2Activity {
	from
		construcOrMethodDec : JAVA!ConstructorDeclaration(construcOrMethodDec.notInAnnotation)
	to
		act	:	UML!Activity(
			name <- construcOrMethodDec.getConstructorName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}	
}

abstract rule abstractConstructorCall2CreateObject {
	from
		ci	:	JAVA!AbstractMethodDeclaration(
			ci.oclIsTypeOf(JAVA!SuperConstructorInvocation)
			or ci.oclIsTypeOf(JAVA!ConstructorInvocation)
		)
	to 
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- ci.getStatement
			
		),
		icf	: UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inStructuredNode <- ci.refImmediateComposite(),
			source <- ci.getPreceding(),
			target <- t
		)	
}

rule superConstructorCall2CreateObject {
	from
		ci	:	JAVA!SuperConstructorInvocation (
			ci.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
			and ci.notInInitializerOrFieldOrEnum 
			and ci.notInAnnotation
		)
	to 
		t	:	UML!StructuredActivityNode(
			name <- 'Super constructor invocation of '+ ci.originalCompilationUnit.name			
		)
}

rule constructorCall2CreateObject {
	from
		ci	:	JAVA!ConstructorInvocation (
			ci.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
			and ci.notInInitializerOrFieldOrEnum 
			and ci.notInAnnotation
		)
	to 
		t	:	UML!StructuredActivityNode(
			name <- 'Constructor invocation of '+ ci.originalCompilationUnit.name			
		)
}

rule Methods2Activity extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(	
			(not construcOrMethodDec.body.oclIsUndefined()) 
				and
			not construcOrMethodDec.isVoidMethod
				and
		 	not construcOrMethodDec.isBuggedModiscoMethod
				and
		 	construcOrMethodDec.notInAnnotation	
		)
	to
		act	:	UML!Activity(
			name <- construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		
		init	:	UML!InitialNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToBody',
			activity <- act,
			target <- construcOrMethodDec.body,
			source <- init 
		),
		
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			activity <- act,
			target <- final,
			source <- construcOrMethodDec.body
		)		
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule Methods2ActivityBugModisco extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	( 
			(not construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isBuggedModiscoMethod
				and
			construcOrMethodDec.notInAnnotation
		)
	to
		act	:	UML!Activity(
			name <-construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		init	:	UML!InitialNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToBody',
			activity <- act,
			target <- construcOrMethodDec.body,
			source <- init 
		),
		
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			activity <- act,
			target <- final,
			source <- construcOrMethodDec.body
		)		
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule VoidMethod2Activity extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(
			(not construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isVoidMethod
				and
			construcOrMethodDec.notInAnnotation	
		)
	to
		act	:	UML!Activity(
			name <- construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		
		init	:	UML!InitialNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToBody',
			activity <- act,
			target <- construcOrMethodDec.body,
			source <- init 
		),
		
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromBodyToFinalNode',
			activity <- act,
			target <- final,
			source <- construcOrMethodDec.body
		)
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule Methods2ActivityEmptyBody extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(	
			(construcOrMethodDec.body.oclIsUndefined()) 
				and
			not construcOrMethodDec.isVoidMethod
				and
		 	not construcOrMethodDec.isBuggedModiscoMethod
				and
		 	construcOrMethodDec.notInAnnotation	
		)
	to
		act	:	UML!Activity(
			name <- construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		init	:	UML!InitialNode(
			activity <- act
		),
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromInitialNodeToFinalNode',
			activity <- act,
			target <- final,
			source <- init 
		)		
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule Methods2ActivityBugModiscoEmptyBody extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	( 
			(construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isBuggedModiscoMethod
				and
			construcOrMethodDec.notInAnnotation
		)
	to
		act	:	UML!Activity(
			name <-construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		init	:	UML!InitialNode(
			activity <- act
		),
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromInitialNodeToFinalNode',
			activity <- act,
			target <- final,
			source <- init 
		)	
	do{
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').oclIsUndefined()) then
				if (construcOrMethodDec.refImmediateComposite().oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.refImmediateComposite(), 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule VoidMethod2ActivityEmptyBody extends constructorAndMethod2Activity {
	from
		construcOrMethodDec	:	JAVA!MethodDeclaration	(
			(construcOrMethodDec.body.oclIsUndefined()) 
				and
			construcOrMethodDec.isVoidMethod
				and
			construcOrMethodDec.notInAnnotation
		)
	to
		act	:	UML!Activity(
			name <- construcOrMethodDec.getMethodName,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility,
			redefinedBehavior <- construcOrMethodDec.redefinedMethodDeclaration
		),
		init	:	UML!InitialNode(
			activity <- act
		),
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromInitialNodeToFinalNode',
			activity <- act,
			target <- final,
			source <- init
		)		
	do{
		thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedOperation <-
			if (not thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').oclIsUndefined()) then
				thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedOperation -> append(operation)
			else OclUndefined endif;
		thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedBehavior <-
			if (not thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').oclIsUndefined()) then
				if (construcOrMethodDec.getInstanciedClass.oclIsTypeOf(JAVA!ClassDeclaration)) then
					thisModule.resolveTemp(construcOrMethodDec.getInstanciedClass, 't').ownedBehavior -> append(act)
				else OclUndefined endif
			else OclUndefined endif;
	}		
}

rule methodCallExpression {
	from
		mi	:	JAVA!MethodInvocation (
			not mi.method.oclIsUndefined()
			and not mi.getStatement.oclIsKindOf(JAVA!ReturnStatement)
			and mi.notInInitializerOrFieldOrEnum
		)
	to
		co	:	UML!CallOperationAction(
			name <- mi.method.name,
			operation <- thisModule.resolveTemp(mi.method, 'operation'),
			inStructuredNode <- mi.getStatement,
			target <- inputPin,
			argument <- mi.arguments->collect(a | 	if a.isPrimitiveType then
														thisModule.createArgument(a)
													else
														thisModule.createArgumentNotPrimitiv(a)
													endif	
													),
			result <- op
		),
		
		of1	:	UML!ObjectFlow (
			name <- 'fromExpressionOutputToCallOperationAction'.concat('_'+mi.method.name),
			source <- thisModule.resolveTemp(mi.expression, 'op'),
			activity <- if mi.method.oclIsKindOf(JAVA!UnresolvedMethodDeclaration)then
							if  mi.method.getCorrespondingDec.oclIsUndefined()
									or not mi.method.getCorrespondingDec.oclIsKindOf(JAVA!MethodDeclaration)then
								mi.method
							else mi.method.getCorrespondingDec endif
						else mi.method endif,
			target <- inputPin
		),
		inputPin	:	UML!InputPin (
			name <- 'objectInput',
			incoming <- of1
		),
	
		op	:	UML!OutputPin (
			name <- 'callOperationActionOutput'	
		)
}

rule superMethodCallExpression {
	from
		mi	:	JAVA!SuperMethodInvocation (mi.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
	to
		cba	:	UML!CallBehaviorAction(
			name <- mi.method.name,
			inStructuredNode <- mi.getStatement,
			argument <- mi.arguments->collect(a | 	if a.isPrimitiveType then
														thisModule.createArgument(a)
													else
														thisModule.createArgumentNotPrimitiv(a)
													endif	
													),
			result <- op
		),
		op	:	UML!OutputPin (
			name <- 'resultOutput'	
		)
}

rule Parameters2ActivityParameterAndParamNode {
	from
		param	:	JAVA!SingleVariableDeclaration(
			param.notInInitializerOrFieldOrEnum	
		) 
	to	
		apn	:	UML!ActivityParameterNode(
			name <- param.name,
			type <- if (param.type.type.oclIsKindOf(JAVA!ParameterizedType)) then
						param.type.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
							param.type.type.elementType.type.excludeUnresolvedTypeDec
						else
							param.type.type.excludeUnresolvedTypeDec 
						endif
					endif,
			parameter <- paramAct		
		),
		
		paramAct	:	UML!Parameter(
			name <- param.name,
			type <- if (param.type.type.oclIsKindOf(JAVA!ParameterizedType)) then
						param.type.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
							param.type.type.elementType.type.excludeUnresolvedTypeDec
						else
							param.type.type.excludeUnresolvedTypeDec 
						endif
					endif
		)
	do{
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode 
			<- 	if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedNode -> append(apn)
				else OclUndefined endif;
		thisModule.resolveTemp(param.getOwningMethod, 'act').ownedParameter 
			<-  if (not thisModule.resolveTemp(param.getOwningMethod, 'act').oclIsUndefined()) then
					thisModule.resolveTemp(param.getOwningMethod, 'act').ownedParameter -> append(paramAct)
				else OclUndefined endif;
	}	
}

rule parameterizedType {
	from
		s	:	JAVA!ParameterizedType
	to
		t	:	UML!Class(
			name <- s.typeArguments -> first().type.name
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}		
}

rule VariableAssignmentNoList {
	from
		as : JAVA!Assignment (	as.isVariableAssignmentNoList
								and as.notInInitializerOrFieldOrEnum 
								and as.notInAnnotation
		)
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- as.getStatement,
			name <- 'declare_'+if (as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))then
									as.leftHandSide.element.name
								else as.leftHandSide.field.variable.name endif
		),	
		
		objectFlowForExpression : UML!ObjectFlow(
			name <- 'fromRightHandSideOutputToInputValue',
			inStructuredNode <- t,
			source <-  thisModule.resolveTemp(as.rightHandSide, 'op'),
			target <- va
		),	
		va	:	UML!InputPin(
			name <- 'valueInput'			
		),
		
		objectFlowForObject : UML!ObjectFlow(
			name <- 'fromLeftHandSideStatementToInputObject',
			inStructuredNode <- t,
			source <- if (not as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))then
						as.leftHandSide.expression.getStatement
					  else OclUndefined endif,
			target <- ip
		),	
		ip	:	UML!InputPin(
			name <- 'objectInput'
		),
		
		strucFeatAction : UML!AddStructuralFeatureValueAction(
			isReplaceAll <- true,
			object <- ip,
			value <- va,
			structuralFeature <- if (not as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))then
									thisModule.createStructFeature(as.leftHandSide.field)
								 else OclUndefined endif,
			inStructuredNode <- t
		),
		
		init : UML!InitialNode(
			inStructuredNode <- t
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		),
		
		cf	: UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inStructuredNode <- as.getStatement,
			source <- as.getPreceding(),
			target <- t
		),
		
		icf1	: UML!ControlFlow(
			name <- 'fromInitialNodeToInternalCurrent',
			inStructuredNode <- t,
			source <- init,
			target <- thisModule.createStructuredActivityNode(t, 'declare_'+
																if (as.leftHandSide.oclIsKindOf(JAVA!UnresolvedItemAccess))
																	then as.leftHandSide.element.name
																else as.leftHandSide.field.variable.name endif
															)
		),
		
		icf2	: UML!ControlFlow(
				name <- 'fromAddStructuralFeatureValueActionToFinalNode',
			inStructuredNode <- t,
			source <- strucFeatAction,
			target <- final
		)
}

rule localVariableAssignmentNoList {
	from
		as	:	JAVA!Assignment  (	as.isLocaleVariableAssignmentNoList
									and as.notInInitializerOrFieldOrEnum 
									and as.notInAnnotation
		)
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- as.getStatement.refImmediateComposite(),
			name <- 'declare_' + as.leftHandSide.variable.name
		),		
		objectFlow : UML!ObjectFlow(
			inStructuredNode <- as.getStatement.refImmediateComposite(),
			name <- 'declare_' + as.leftHandSide.variable.name,
			source <- as.rightHandSide.getStatement,
			target <- forkNode
		),	
		forkNode : UML!ForkNode(
			name <- 'fromRightHandSide',
			inStructuredNode <- as.getStatement.refImmediateComposite()
		),
		icf	: UML!ControlFlow(
			name <- 'fromPrecedingNodeToCurrent',
			inStructuredNode <- as.getStatement.refImmediateComposite(),
			source <- as.getStatement.getPreceding(),
			target <- t
		)			
}

rule variableAssignementListOrArray {
	from
		iva	:	JAVA!Assignment (	(
										iva.isVariableAssignmentList										
										or
										iva.isAbsDecMethContainedAndArray
									)	
									and iva.notInInitializerOrFieldOrEnum 
									and iva.notInAnnotation
		)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Variable assignement - List or array',
			inStructuredNode <- iva.refImmediateComposite().refImmediateComposite()
		),
		
		fork : UML!ForkNode(
			name <- 'fromLeftHandSide',
			inStructuredNode <- iva.refImmediateComposite().refImmediateComposite()
		),
		
		--Object to fork
		objFlowForObjInFork : UML!ObjectFlow(
			name <- 'fromLeftHandSideToFork',
			source <- 	if (not iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess) 
							and not iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess)
						)then
							iva.leftHandSide.expression
						else
							iva.leftHandSide.getStatement
						endif,
			target <- fork,
			inStructuredNode <- iva.refImmediateComposite()
		),
		
		--Fork to ClearStruc.Feature
		objFlowForObjCFS : UML!ObjectFlow(
			name <- 'fromForkToClearStructuralFeatureInput',
			source <- fork,
			target <- inputClearStrucFeat,
			inStructuredNode <- iva.refImmediateComposite()
		),		
		inputClearStrucFeat : UML!InputPin(
			name <- 'objectInputOfClearStructuralFeature'
		),
		
		--Fork to Exp.Region
		objFlowForObjExpReg	: UML!ObjectFlow(
			name <- 'fromForkToExpansionRegionInput',
			source <- fork,
			target <- inputExpReg,
			inStructuredNode <- iva.refImmediateComposite()
		),
		inputExpReg : UML!InputPin(
			name <- 'objectInputOfExpansionRegion',
			inStructuredNode <- expReg,
			lower <- 1,
			upper <- 1
		),
		
		--ClearStruc.Feature 
		clearStructuralFeature : UML!ClearStructuralFeatureAction(
			object <- inputClearStrucFeat,
			outgoing <- contFlowCSFExpReg,
			structuralFeature <- 	if (not iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess)
										and not iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess)
									)then
										thisModule.createStructFeature(iva.leftHandSide.field)
									else
										if (iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess))then
											if (iva.leftHandSide.array.oclIsTypeOf(JAVA!SingleVariableAccess))then
												thisModule.createStructFeature(iva.leftHandSide.array)
											else OclUndefined endif	
										else 
											if (iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess))then
												thisModule.createStructFeature(iva.leftHandSide)
											else OclUndefined endif
										endif	
									endif,
			inStructuredNode <- iva.refImmediateComposite()
		),
		
		--ClearStruc.Feature to Exp.Region
		contFlowCSFExpReg	:	UML!ControlFlow(
			name <- 'fromClearStructuralFeatureActionToExpansionRegion',
			source <- clearStructuralFeature,
			target <- expReg,
			inStructuredNode <- iva.refImmediateComposite()
		),
				
		--ValueSpecAction to 'insertAt' object flow
		valueSpecAction	:	UML!ValueSpecificationAction(
			result <- op,
			value <- literUnlimNatur,
			inStructuredNode <- iva.refImmediateComposite()
		),
		literUnlimNatur : UML!LiteralUnlimitedNatural(
			value <- -1
		),
		op : UML!OutputPin(
			name <- 'outputValueSpecAction'
		),
		
		--Output of ValueSpecAction to input of Exp.Region 'insertAt'
		objFlowForObjInsertAt : UML!ObjectFlow(
			name <- 'fromValueSpecificationActionOutputToExpansionRegionInput',
			source <- op,
			target <- inputExpRegInsertAt,
			inStructuredNode <- iva.refImmediateComposite()
		),		
		inputExpRegInsertAt : UML!InputPin(	
			name <- 'insertAtInput',
			inStructuredNode <- expReg,
			lower <- 1,
			upper <- 1
		),
		
		--Exp.Region to AddStruct.FeatureValue
		expReg : UML!ExpansionRegion(
			incoming <- contFlowCSFExpReg,
			inputElement <- expNode,
			inStructuredNode <- iva.refImmediateComposite()
		),
		addStructuralFeatureAction : UML!AddStructuralFeatureValueAction(
			isReplaceAll <- false,
			inStructuredNode <- expReg,
			object <- inputObjectAddStrucFeat,
			value <- valueExpression,			
			insertAt <- insertAtValueSpecAction,
			structuralFeature <- 	if (not iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess)
										and not iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess)
									)then
										thisModule.createStructFeature(iva.leftHandSide.field)
									else
										if (iva.leftHandSide.oclIsTypeOf(JAVA!ArrayAccess))then
											if (iva.leftHandSide.array.oclIsTypeOf(JAVA!SingleVariableAccess))then
												thisModule.createStructFeature(iva.leftHandSide.array)
											else OclUndefined endif	
										else	
											if (iva.leftHandSide.oclIsTypeOf(JAVA!SingleVariableAccess))then
												thisModule.createStructFeature(iva.leftHandSide)
											else OclUndefined endif
										endif	
									endif
		),
		
		expNode	:	UML!ExpansionNode(
			name <- 'inputElementOfExpansionRegion',
			inStructuredNode <- expReg
		),
		
		objFlowExpRegToAddStruct : UML!ObjectFlow(
			name <- 'fromInputExpRegToInputAddStruct',
			inStructuredNode <- expReg,
			source <- inputExpReg,
			target <- inputObjectAddStrucFeat			
		),
		inputObjectAddStrucFeat : UML!InputPin(
			name <- 'objectInputAddStructuralFeatureValueAction'
		),		
		
		objFlowValueToAddStruct	: UML!ObjectFlow(
			name <- 'fromInputExpRegValueToInputAddStruct',
			inStructuredNode <- expReg,
			source <- inputClearStrucFeat,
			target <- valueExpression
		),
		valueExpression	: UML!InputPin(
			name <- 'valueInputAddStructuralFeatureValueAction'
		),
		
		objFlowInsertAtToAddStruct : UML!ObjectFlow(
			name <- 'fromInputExpRegInsertAtToInputAddStruct',
			inStructuredNode <- expReg,
			source <- inputExpRegInsertAt,
			target <- insertAtValueSpecAction
		),
		insertAtValueSpecAction	: UML!InputPin(
			name <- 'insertAtInputAddStructuralFeatureValueAction'
		)		
}

rule conditionalExpression { --simplifed mapping in case of empty else branch
	from
		ifs	:	JAVA!ConditionalExpression (ifs.notInInitializerOrFieldOrEnum and ifs.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			inStructuredNode <- ifs.getStatement,
			name <- 'Conditionnal'
		),
				
		td	:	UML!ObjectFlow(
			name <- 'fromActivityNodeToDecisionNode',
			inStructuredNode <- t,
			source <- ifs.expression.getActivityNode(),
			target <- dec,
			name <- '<<decisionInputFlow>>'
		),
		dec	:	UML!DecisionNode(
			decisionInputFlow <- td, 
			inStructuredNode <- t			
		),
		
		tru	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToThenStatement',
			inStructuredNode <- t,
			source <- dec,
			target <- ifs.thenExpression.getStatement,
			guard <- uvt
		),
		
		fal	:	UML!ControlFlow(
			name <- 'fromDecisionNodeToElseStatement',
			inStructuredNode <- t,
			source <- dec,
			target <- 	if ifs.elseExpression.oclIsUndefined()
						then thisModule.createEmptyElse(ifs)
						else 
							ifs.elseExpression.getStatement							
						endif,
			guard <- uvf
		),
		
		uvt	:	UML!LiteralBoolean(
			value <- true
		),
		uvf	:	UML!LiteralBoolean(
			value <- false
		),
		
		jn	:	UML!JoinNode(
			inStructuredNode <- t
		),		
		id2	:	UML!ControlFlow(
			name <- 'fromJoinNodeToFinalNode',
			inStructuredNode <- t,
			source <- jn,
			target <- final
		),	
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

rule expression{
	from
		s	:	JAVA!Expression (					
					(s.refImmediateComposite().oclIsKindOf(JAVA!IfStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!ForStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!DoStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!EnhancedForStatement) 
							or s.refImmediateComposite().oclIsKindOf(JAVA!WhileStatement)
							or s.refImmediateComposite().oclIsKindOf(JAVA!ReturnStatement)
					 ) 
					 	and 
					 s.notInInitializerOrFieldOrEnum 
					 	and 
					s.notInAnnotation 
						and
					s.alreadyManage
		)
	to
		t : UML!StructuredActivityNode(
			name <- 'expression',
			inStructuredNode <- s.refImmediateComposite()
		)
}

rule expressionForVarDeclaration{
	from
		s	:	JAVA!Expression(
					(	s.refImmediateComposite().oclIsKindOf(JAVA!VariableDeclarationFragment) 
								and
						s.refImmediateComposite().refImmediateComposite().oclIsKindOf(JAVA!VariableDeclarationStatement) 
					 ) 
						and
					s.notInInitializerOrFieldOrEnum 
						and 
					s.notInAnnotation 
						and 
					s.alreadyManage
				)					 
	to
		t : UML!StructuredActivityNode(
			name <- 'expression',
			inStructuredNode <- s.refImmediateComposite().refImmediateComposite()
		)
}

---Concerns the use of field directly using 'this'
rule explicitThis2readSelf {
	from
		this	:	JAVA!ThisExpression (this.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
	to
		read	:	UML!ReadSelfAction (
			result <- op,
			inStructuredNode <- this.getStatement.refImmediateComposite()
		),
		op	:	UML!OutputPin (
			name <- 'resultReadSelfActionOutput'	
		)
}

rule parenthesizedExpression {
	from
		s	:	JAVA!ParenthesizedExpression (s.notInInitializerOrFieldOrEnum and s.notInAnnotation)
	to
		t	:	UML!StructuredActivityNode(
			name <- 'Parenthesized',
			inStructuredNode <- s.getStatement
		),	
		
		initialNode : UML!InitialNode(
			inStructuredNode <- t
		),
		initialControlFlow: UML!ControlFlow(
			name <- 'fromInitialNodeToStatement',
			inStructuredNode <- t,
			source <- initialNode,
			target <- s.expression.getStatement
		),
		
		finalControlFlow: UML!ControlFlow(
			name <- 'fromStatementToFinalNode',
			inStructuredNode <- t,
			source <- s.expression.getStatement,
			target <- final
		),
		final : UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

abstract rule operatorexpression {
	from
		ioe	:	JAVA!Expression
	to
		cb	:	UML!CallBehaviorAction(
			behavior <- ioe.getBehavior,
			name <- ioe.operator.toString(),
			inStructuredNode <- ioe.getStatement,
			argument <- Sequence{inputPinOperand},
			result <- op
		),		
		
		inputPinOperand : UML!InputPin (
			name <- 'objectInput'
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromOperandToCallBehaviorInput',
			source <- thisModule.resolveTemp(ioe.operand, 'op'),
			inStructuredNode <- ioe.getStatement,
			target <- inputPinOperand
		),
		
		op	:	UML!OutputPin (
			name <- 'resultCallBehaviorOutput'	
		)	
}

rule postfixOperatorExpression extends operatorexpression{
	from
		ioe	:	JAVA!PostfixExpression  (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
				and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
		)
	to
		cb	:	UML!CallBehaviorAction()	
}

rule prefixOperatorExpression extends operatorexpression{
	from
		ioe	:	JAVA!PrefixExpression  (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)	
				and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
		)
	to
		cb	:	UML!CallBehaviorAction()
}

rule infixOperatorExpression {
	from
		ioe	:	JAVA!InfixExpression ((Sequence{'==','!='}->excludes(ioe.operator.toString()))  
										and (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))	
										and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
		)
	to
		cb	:	UML!CallBehaviorAction(	
			behavior <- ioe.getBehavior,
			name <- ioe.operator.toString(),
			inStructuredNode <- ioe.getStatement,
			argument <- Sequence{inputPinFirstLeft, inputPinSecondRight},
			result <- op
		),
		
		inputPinFirstLeft : UML!InputPin (
			name <- 'first'
		),
		of1	:	UML!ObjectFlow (
			name <- 'fromLeftOperandToCallBehaviorAction',
			source <- thisModule.resolveTemp(ioe.leftOperand, 'op'),
			inStructuredNode <- ioe.getStatement,
			target <- inputPinFirstLeft
		),
		
		inputPinSecondRight	: UML!InputPin (
			name <- 'second'
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromRightOperandToCallBehaviorAction',
			source <- thisModule.resolveTemp(ioe.rightOperand, 'op'),
			inStructuredNode <- ioe.getStatement,
			target <- inputPinSecondRight
		),
		
		op	:	UML!OutputPin (
			name <- 'resultCallBehaviorActionOutput'
		)
}

rule equalOperatorExpression{
	from
		ioe	:	JAVA!InfixExpression ((Sequence{'=='}->includes(ioe.operator.toString())) 
			and (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))	
			and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
		)
	to
		ti	:	UML!TestIdentityAction(
			name <- ioe.operator.toString(),
			inStructuredNode <- ioe.getStatement,			
			first <- ipl,
			second <- ipr,
			result <- op
		),
		ipl	:	UML!InputPin (
			incoming <- of1,
			name <- 'first'
		),
		of1	:	UML!ObjectFlow (
			name <- 'fromLeftOperandToTestIdentityAction',
			source <- if (ioe.leftOperand.isAccessExpression) then
							thisModule.resolveTemp(ioe.leftOperand.getVarAccessExpression, 'apn')
					  else	ioe.leftOperand.getStatement endif,
			target <- ipl,
			activity <- ioe.getOwningMethod
		),
		ipr	:	UML!InputPin (
			incoming <- of2,
			name <- 'second'
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromRightOperandToTestIdentityAction',
			source <- 	if (ioe.rightOperand.isAccessExpression) then
							thisModule.resolveTemp(ioe.rightOperand.getVarAccessExpression, 'apn')
						else ioe.rightOperand.getStatement endif,
			target <- ipr,
			activity <- ioe.getOwningMethod
		),
		op	:	UML!OutputPin (
			name <- 'resultTestIdentityActionOutput'	
		)
}

rule notEqualOperatorExpression {
	from
		ioe	:	JAVA!InfixExpression ((Sequence{'!='}->includes(ioe.operator.toString())) 
			and (ioe.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
			and (ioe.notInInitializerOrFieldOrEnum and ioe.notInAnnotation)	
		)
	to
		cb	:	UML!TestIdentityAction(
			name <- ioe.operator.toString(),
			inStructuredNode <-if (ioe.refImmediateComposite().isInMethodOrConstructor) then
									ioe.getStatement.refImmediateComposite()
								else
									ioe.getStatement
								endif,
			first <- ipl,
			second <- ipr,
			result <- op
		),
		
		ipl	:	UML!InputPin (
			incoming <- of1,
			name <- 'first'
		),
		of1	:	UML!ObjectFlow (
			name <- 'fromLeftOperandToTestIdentityAction',
			source <- if (ioe.leftOperand.isAccessExpression) then
							thisModule.resolveTemp(ioe.leftOperand.getVarAccessExpression, 'apn')
					  else ioe.leftOperand.getStatement endif,	
			target <- ipl,
			activity <- ioe.getOwningMethod
		),
		
		ipr	:	UML!InputPin (
			incoming <- of2,
			name <- 'second'
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromRightOperandToTestIdentityAction',
			source <- if (ioe.rightOperand.isAccessExpression) then
							thisModule.resolveTemp(ioe.rightOperand.getVarAccessExpression, 'apn')
					  else ioe.rightOperand.getStatement endif,
			target <- ipr,
			activity <- ioe.getOwningMethod
		),
		
		op	:	UML!OutputPin (
			name <- 'resultTestIdentityActionOutput'	
		)
}


rule typeCastExpression {
	from 
		tce	:	JAVA!CastExpression (not tce.type.type.oclIsKindOf(JAVA!PrimitiveType)
			and (tce.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
			and (tce.notInInitializerOrFieldOrEnum and tce.notInAnnotation)	
		)
	to
		t :	UML!StructuredActivityNode (
			name <- 'cast to '+tce.type.type.name,
			inStructuredNode <- if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement
								endif
			,
			edge <- of2,
			structuredNodeInput <- Sequence{inputPin},
			structuredNodeOutput <-  op
		),
		
		inputPin : UML!InputPin (
			name <- 'structuredNodeInput'
		),
		of	:	UML!ObjectFlow (
			name <- 'fromActivityNodeToPrecedingStructuredActivityNode',
			source <- 	tce,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement
								endif,
			target <- inputPin
		),
		
		cf	:	UML!ControlFlow (
			name <- 'fromActivityNodeToStructuredActivityNode',
			source <- tce,
			target <- t,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement
								endif
		),
		
		of2	:	UML!ObjectFlow (
			name <- 'InternalStructuredActivityNodeObjectFlow',
			source <- inputPin,
			target <- op
		),
		
		op	:	UML!OutputPin (
			name <- 'internalStructuredActivityNodeOutput',
			type <- if (not tce.type.type.oclIsKindOf(JAVA!ArrayType))then
						tce.type.type.excludeUnresolvedTypeDec
					else 
						tce.type.type.elementType.type.excludeUnresolvedTypeDec 
					endif
		)
}


rule numericCastExpression {
	from 
		tce	:	JAVA!CastExpression (
				tce.isANumericCast
				and (tce.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration))
				and (tce.notInInitializerOrFieldOrEnum and tce.notInAnnotation)
		)
	to
		san :	UML!CallBehaviorAction (
			name <- 'to '+tce.type.type.name,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement
								endif
								,
			argument <- Sequence{ip},
			result <- op
		),
		
		ip	:	UML!InputPin (
			name <- 'CallBehaviorActionInput'
		),
		of	:	UML!ObjectFlow (
			name <- 'fromExpressionOutputToCallBehaviorAction',
			source <- thisModule.resolveTemp(tce.expression, 'op'),
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement
								endif,
			target <- ip				
		),
		
		op	:	UML!OutputPin (
			name <- 'resultCallBehaviorActionOutput',
			type <- tce.type.type.excludeUnresolvedTypeDec
		)
}

rule instanceOf {
	from 
		tce	:	JAVA!InstanceofExpression(	tce.notInInitializerOrFieldOrEnum 
											and tce.notInAnnotation)
	to
		san :	UML!ReadIsClassifiedObjectAction (
			name <- 'instanceOf ' + tce.rightOperand.type.name,
			inStructuredNode <-  if (tce.refImmediateComposite().oclIsKindOf(JAVA!ParenthesizedExpression)) then 
									tce.refImmediateComposite()
								else
									tce.getStatement
								endif,
			object <- ip,
			result <- op,
			classifier <- tce.getInstanciedClass
		),
		
		ip	:	UML!InputPin (
			name <- 'instanceOf ' + tce.rightOperand.type.name + '_object'
		),
		incomObject : UML!ObjectFlow(
			name <- 'fromParametersToReadIsClassifiedObjectAction',
			activity <- tce.getOwningMethod,
			source <- let firstParam : OclAny = 
						tce.getOwningMethod.parameters
							-> collect(param | thisModule.resolveTemp(param, 'apn'))
							-> flatten() -> first()
					   in 
					   if (not firstParam.oclIsKindOf(JAVA!TypeLiteral)) then
						firstParam
					  else OclUndefined endif,
			target <- ip
		),
		
		op : UML!OutputPin (
			name <- 'instanceOf ' + tce.rightOperand.type.name + '_result',
			outgoing <- outComObject
		),
		outComObject : UML!ObjectFlow(
			name <- 'fromReadIsClassifiedObjectActionToActivityParameterNode',
			activity <- tce.getOwningMethod,
			source <- op,
			target <- 	if (not tce.getOwningMethod.body.oclIsUndefined())then
							thisModule.resolveTemp(tce.getOwningMethod.body.statements
													-> select(state | state.oclIsTypeOf(JAVA!ReturnStatement))
													-> first(),
													'apn'
							)						
						else OclUndefined endif
		)
}

rule unresolvedItemAccess {
	from
		s	:	JAVA!UnresolvedItemAccess(
			not s.getStatement.oclIsUndefined()	
		)
	to
		t	:	UML!OpaqueAction(
			name <- 'UnresolvedItemAccess_'+s.element.name,
			inStructuredNode <- s.getStatement
		)
}

rule unresolvedAnnotationDeclaration{
	from
		s	:	JAVA!UnresolvedAnnotationDeclaration
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported'	
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule wildCardType{
	from
		s	:	JAVA!WildCardType
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported'	
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule PrimitiveType {
	from
		s	:	JAVA!PrimitiveType
	to
		t	:	UML!PrimitiveType(
			name <- s.name	
		)
}

rule annotationTypeDeclaration{
	from
		s	:	JAVA!AnnotationTypeDeclaration
	to
		t	:	UML!Class(
			name <- s.name + '-unsupported'	
		)
	do{
		thisModule.getTypeDec <- thisModule.getTypeDec -> including(s, t);	
	}	
}

rule stringLiteral2ValueSpecification {
	from
		sl	:	JAVA!StringLiteral (if (sl.notInAnnotation) then 
									sl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration) 
									else false endif
		)
	to
		vsa	:	UML!ValueSpecificationAction (
			result <- op,
			value <- vs,
			inStructuredNode <- sl.getStatement
		),
		vs	:	UML!LiteralString(
			value <- sl.escapedValue.regexReplaceAll('"', '')
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'
		)
}

rule charLiteral2ValueSpecification {
	from
		cl	:	JAVA!CharacterLiteral ( if (cl.notInAnnotation) then 
										cl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
										else false endif
			)
	to
		vsa	:	UML!ValueSpecificationAction (
			result <- op,
			value <- vs,
			inStructuredNode <- cl.getStatement
		),
		vs	:	UML!LiteralString(
			value <- cl.escapedValue.regexReplaceAll('"', '')
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'
		)
}

rule Booleanliteral2ValueSpecification {
	from
		bl	:	JAVA!BooleanLiteral (
			bl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
			and bl.notInAnnotation
		)
	to
		vsa	:	UML!ValueSpecificationAction (
			result <- op,
			value <- vs,
			inStructuredNode <- bl.getStatement
		),
		vs	:	UML!LiteralBoolean(
			value <- bl.value
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'	
		)
}

rule numberLiteral2ValueSpecification {
	from
		nl	:	JAVA!NumberLiteral (
			(nl.tokenValue.indexOf('.')=-1) 
			and nl.notInInitializerOrFieldOrEnum				
			and nl.notInAnnotation
		)
	to 
		vsa	:	UML!ValueSpecificationAction (
			name <- nl.toString().concat('_RIC : ' + nl.refImmediateComposite()+'_Type : '+nl.oclType().toString()),
			result <- op,
			value <-vs,
			inStructuredNode <- nl.getStatement
		),
		vs	:	UML!LiteralInteger(
			value <- nl.tokenValue.regexReplaceAll('[A-Za-z]', '').toInteger()
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'	
		)
}

rule realNumberLiteral2ValueSpecification {
	from
		nl	:	JAVA!NumberLiteral (
			(not (nl.tokenValue.indexOf('.')=-1)  
			and	nl.notInInitializerOrFieldOrEnum)
			and nl.notInAnnotation
		)
	to 
		vsa	:	UML!ValueSpecificationAction (
			name <- nl.toString(),
			result <- op,
			value <-vs,
			inStructuredNode <- nl.getStatement
		),
		vs	:	UML!LiteralReal(
			value <- nl.tokenValue.regexReplaceAll('[A-Za-z]', '').toReal()
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'	
		)
}

rule nullLiteral2ValueSpecification {
	from
		nl	:	JAVA!NullLiteral (
			nl.getOwningMethod.oclIsKindOf(JAVA!AbstractMethodDeclaration)
			and nl.notInAnnotation
		)
	to 
		vsa	:	UML!ValueSpecificationAction (
			name <- nl.toString(),
			result <- op,
			value <-OclUndefined,
			inStructuredNode <- nl.getStatement
		),
		op	:	UML!OutputPin (
			name <- 'resultValueSpecificationActionOutput'
		)
}

---Lazy rules
unique lazy rule createArgumentNotPrimitiv {
	from
		a	:	JAVA!Expression
	to
		inputPin : UML!InputPin (
			name <- 'objectInput',
			incoming <- of2
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromExpressionOutput',
			source <- thisModule.resolveTemp(a, 'op'),
			activity <- if a.refImmediateComposite().method.oclIsKindOf(JAVA!UnresolvedMethodDeclaration)then
							if  a.refImmediateComposite().method.getCorrespondingDec.oclIsTypeOf(JAVA!MethodDeclaration)then
								a.refImmediateComposite().method.getCorrespondingDec
							else a.refImmediateComposite().method									
							endif
						else a.refImmediateComposite().method 								
						endif 
		),
		cf	:	UML!ControlFlow (
			name <- 'fromExpressionOutputToStatement',
			source <- thisModule.resolveTemp(a, 'op'),
			activity <- if a.refImmediateComposite().method.oclIsKindOf(JAVA!UnresolvedMethodDeclaration)then
							if  not a.refImmediateComposite().method.getCorrespondingDec.oclIsTypeOf(JAVA!MethodDeclaration)then
								a.refImmediateComposite().method
							else a.refImmediateComposite().method.getCorrespondingDec endif
						else a.refImmediateComposite().method endif,
			target <- 	if (a.refImmediateComposite().getStatement.oclIsKindOf(JAVA!ReturnStatement))then
							thisModule.resolveTemp(a.refImmediateComposite().getStatement, 'co')
						else a.refImmediateComposite() endif
		)
}

unique lazy rule createArgument {
	from
		a	:	JAVA!Expression
	to
		inputPin : UML!InputPin (
			name <- 'objectInput',
			incoming <- of2
		),
		of2	:	UML!ObjectFlow (
			name <- 'fromExpressionOutputToStatement',
			source <- thisModule.resolveTemp(a, 'op'),
			inStructuredNode <- a.getStatement
		)
}

unique lazy rule Parameters2ActivityParameter{
	from
		param	:	JAVA!SingleVariableDeclaration 
	to	
		paramAct	:	UML!Parameter(
			name <- param.name,
			type <-	if (param.type.type.oclIsKindOf(JAVA!ParameterizedType)) then
						param.type.type.typeArguments ->first().type.excludeUnresolvedTypeDec
					else 
						if (param.type.type.oclIsKindOf(JAVA!ArrayType)) then
							param.type.type.elementType.type.excludeUnresolvedTypeDec
						else
							param.type.type.excludeUnresolvedTypeDec
						endif
					endif
		)
}


rule arrayToClass {
	from
		arrayType	:	JAVA!ArrayType
	to
		umlClass	:	UML!Class(
			name <- arrayType.elementType.type.name+'[]',
			ownedAttribute <- umlProperty			
		), 
		umlProperty	:	UML!Property(
			type <- if (arrayType.elementType.type.oclIsKindOf(JAVA!TypeParameter)) then
							arrayType.elementType.type.excludeUnresolvedTypeDec
					else 
						arrayType.elementType.type.excludeUnresolvedTypeDec
					endif,
			name <- 'type'		
		)
}

rule typeParameterToClass {
	from 
		jBodyDec : JAVA!TypeParameter
	to 
		umlElement : UML!Class( 
				name <- jBodyDec.name
		)
}

unique lazy rule createEmptyElse{
	from
		ifs	:	JAVA!IfStatement
	to
		t : UML!StructuredActivityNode(
			inStructuredNode <- ifs,
			name <- 'Empty Else'
		)
}

unique lazy rule createListGetFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		listGet : UML!OpaqueBehavior(
			name <- 'ListGet',
			ownedParameter <- Sequence{list, index, result}
		),
		list : UML!Parameter(
			name <- 'list'	
		),
		index : UML!Parameter(
			name <- 'index'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(listGet);
	}	
}

unique lazy rule createIntegerMinusFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerMinus : UML!OpaqueBehavior(
			name <- 'IntegerMinus',
			ownedParameter <- Sequence{x, y, result}			
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerMinus);
	}	
}

unique lazy rule createIntegerPlusFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerPlus : UML!OpaqueBehavior(
			name <- 'IntegerPlus',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerPlus);
	}
}

unique lazy rule createIntegerTimesFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerTimes : UML!OpaqueBehavior(
			name <- 'IntegerTimes',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerTimes);
	}	
}

unique lazy rule createIntegerDivideFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerDivide : UML!OpaqueBehavior(
			name <- 'IntegerDivide',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerDivide);
	}	
}

unique lazy rule createIntegerLessFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerLess : UML!OpaqueBehavior(
			name <- 'IntegerLess',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerLess);
	}
}

unique lazy rule createIntegerGreaterFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerGreater : UML!OpaqueBehavior(
			name <- 'IntegerGreater',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerGreater);
	}
}

unique lazy rule createIntegerLessOrEqualsFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerLessOrEquals : UML!OpaqueBehavior(
			name <- 'IntegerLessOrEquals',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerLessOrEquals);
	}	
}

unique lazy rule createIntegerGreaterOrEqualsFumlLib{
	from
		s	:	JAVA!ExpressionStatement
	to
		integerGreaterOrEquals : UML!OpaqueBehavior(
			name <- 'IntegerGreaterOrEquals',
			ownedParameter <- Sequence{x, y, result}
		),
		x : UML!Parameter(
			name <- 'x'	
		),
		y : UML!Parameter(
			name <- 'y'	
		),
		result : UML!Parameter(
			name <- 'result'	
		)
	do{
		thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier 
			<- thisModule.resolveTemp(s.getInstanciedClass, 't').nestedClassifier -> append(integerGreaterOrEquals);
	}
}


unique lazy rule createObjectFlowToVSA{
	from
		s	:	JAVA!ExpressionStatement
	to
		valueSpecActionOF : UML!ObjectFlow(
			name <- 'objectFlowFromValueSpecificationAction',
			source <- valueSpecAction,
			inStructuredNode <- s.getStatement
		),
		valueSpecAction	: UML!ValueSpecificationAction(
			value <- literUnlimNatur,
			inStructuredNode <- s.refImmediateComposite()
		),
		literUnlimNatur : UML!LiteralUnlimitedNatural(
			value <- -1
		)
}

unique lazy rule createObjectFlowToNode{
	from
		s	:	JAVA!ExpressionStatement
	to
		insertAtOF : UML!ObjectFlow(
			name <- 'objectFlowFromNode',
			source <- 	s.expression.arguments 
							-> reject(arg | arg.isALiteral)
							-> select(arg | arg.getVarAccessExpression.name = 'insertAt')
							-> collect(arg | arg.getVarAccessExpression)
							-> flatten()
							-> first(),
			inStructuredNode <- s.getStatement				
		)
}

unique lazy rule createStructFeature{
	from
		singleAccess : JAVA!Expression
	to
		struct : UML!Property(
			name <- if (singleAccess.oclIsKindOf(JAVA!InfixExpression)) then
						if (singleAccess.leftOperand.oclIsKindOf(JAVA!UnresolvedItemAccess)) then
							singleAccess.leftOperand.element.name
						else singleAccess.leftOperand.name endif
					else
						if (not singleAccess.isALiteral and not singleAccess.oclIsKindOf(JAVA!TypeAccess))then
							singleAccess.variable.name
						else 
							if (singleAccess.type.oclIsKindOf(JAVA!ClassDeclaration))then
								singleAccess.type.name
							else							
								singleAccess.type.type.name 
							endif
						endif	
					endif	
					,
			type <- if (singleAccess.getVariableType.oclIsKindOf(JAVA!ParameterizedType)) then 
						singleAccess.getVariableType.typeArguments -> first().type.excludeUnresolvedTypeDec
					else 
						if (singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType)) then
							singleAccess.getVariableType.elementType.type.excludeUnresolvedTypeDec
						else
							singleAccess.getVariableType.excludeUnresolvedTypeDec
						endif	
					endif,
			lower <- if (singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType)) then
						1
					else 0 endif,
			upper <- if (singleAccess.isAList or singleAccess.isASet
							or singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType)) then
						-1
					else 1 endif,
			isUnique <-  singleAccess.isASet,
			isOrdered <- singleAccess.isAList or singleAccess.getVariableType.oclIsKindOf(JAVA!ArrayType),
			visibility <- 	if (not singleAccess.isALiteral and not singleAccess.oclIsKindOf(JAVA!TypeAccess)
								and not singleAccess.oclIsKindOf(JAVA!InfixExpression))then
								if (singleAccess.variable.oclIsKindOf(JAVA!VariableDeclarationFragment))then
									if (singleAccess.variable.variablesContainer.oclIsKindOf(JAVA!FieldDeclaration))then
										singleAccess.variable.variablesContainer.getFieldVisibility
									else OclUndefined endif		
								else OclUndefined endif	
							else 								
								if (singleAccess.oclIsKindOf(JAVA!InfixExpression)) then
									if (singleAccess.leftOperand.oclIsKindOf(JAVA!MethodInvocation)) then
										if (singleAccess.leftOperand.method.oclIsKindOf(JAVA!MethodDeclaration)) then
											singleAccess.leftOperand.method.modifier.visibility
										else #package endif
									else
										if (singleAccess.leftOperand.oclIsKindOf(JAVA!UnresolvedItemAccess)) then
											#package
										else 
											singleAccess.leftOperand.type.modifier.visibility 
										endif
									endif	
								else
									if (singleAccess.oclIsKindOf(JAVA!TypeAccess) 
										and singleAccess.type.oclIsKindOf(JAVA!ClassDeclaration))then
										singleAccess.type.modifier.visibility
									else
										singleAccess.type.type.modifier.visibility
									endif
								endif
							endif	
		)
	do{
		if (not thisModule.resolveTemp(singleAccess.getInstanciedClass, 't').oclIsUndefined())then
			thisModule.resolveTemp(singleAccess.getInstanciedClass, 't').refSetValue('ownedAttribute', struct)
		else OclUndefined endif;
	}	
}

unique lazy rule createOutputPin{
	from
		s	:	JAVA!ExpressionStatement, outputPinName : String
	to
		op : UML!OutputPin (
			name <- outputPinName
		)
}

unique lazy rule createStructuredActivityNode{
	from
		otherT :	UML!StructuredActivityNode, sanName : String
	to
		t :	UML!StructuredActivityNode(
			inStructuredNode <- otherT,
			name <- sanName
		)
}

unique lazy rule createActivityFinalNode {
	from
		t : UML!StructuredActivityNode
	to
		final	:	UML!ActivityFinalNode(
			inStructuredNode <- t
		)
}

---Called rules

rule createObjectFlow(forkNode : UML!ForkNode, otherVDState : JAVA!VariableDeclarationStatement, inputPinOfOtherVDState : UML!InputPin){
	to
		oFFromForkNode : UML!ObjectFlow(
			name <- otherVDState.fragments->first().name+'_object_flow_from_fork_node',
			inStructuredNode <- otherVDState.refImmediateComposite(),			
			source <- forkNode,
			target <- inputPinOfOtherVDState
		)	
	do{
		oFFromForkNode;	
	}	
}

--***************Unresolved items***************
rule JUnresolvedItemToUmlClass {
	from 
		jUnresItem : JAVA!UnresolvedItem(
			not jUnresItem.oclIsTypeOf(JAVA!UnresolvedMethodDeclaration)
			and not jUnresItem.oclIsTypeOf(JAVA!UnresolvedLabeledStatement)
			and
			(
				jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!ClassDeclaration)
				or
				jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!ImportDeclaration)
			)
		)
	to 
		umlNamedElement : UML!Class(
			name <- jUnresItem.name,
			package <- thisModule.createExternalsModel(thisModule.jModelRoot)
		)
}

rule JUnresolvedItemToUmlInterface {
	from 
		jUnresItem : JAVA!UnresolvedItem(
			not jUnresItem.oclIsTypeOf(JAVA!UnresolvedMethodDeclaration)
			and not jUnresItem.oclIsTypeOf(JAVA!UnresolvedLabeledStatement)
			and (jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!InterfaceDeclaration))
		)
	to 
		umlNamedElement : UML!Interface(
			name <- jUnresItem.name,
			package <- thisModule.createExternalsModel(thisModule.jModelRoot) 
		)
}

rule JUnresolvedItemToUmlEnum {
	from 
		jUnresItem : JAVA!UnresolvedItem(
			not jUnresItem.oclIsTypeOf(JAVA!UnresolvedMethodDeclaration)
			and not jUnresItem.oclIsTypeOf(JAVA!UnresolvedLabeledStatement)
			and (jUnresItem.getCorrespondingDec.oclIsTypeOf(JAVA!EnumDeclaration))
		)
	to 
		umlNamedElement : UML!Enumeration(
			name <- jUnresItem.name,
			package <- thisModule.createExternalsModel(thisModule.jModelRoot)
		)
}

rule JUnresolvedMethodDecToActivity{
	from 
		construcOrMethodDec : JAVA!UnresolvedMethodDeclaration(
			not construcOrMethodDec.getCorrespondingDec.oclIsKindOf(JAVA!MethodDeclaration)
		)
	to 
		act	:	UML!Activity(
			name <- construcOrMethodDec.name,
			visibility <- construcOrMethodDec.getAbsMethDecVisibility
		),
		
		init	:	UML!InitialNode(
			activity <- act
		),
		icf : UML!ControlFlow(
			name <- 'fromIntialNodeToOpaqueAction',
			activity <- act,
			target <- opaqueAction,
			source <- init 
		),
		
		opaqueAction : UML!OpaqueAction(
			name <- 'OpaqueAction_UnresolvedMethodDelaration',
			activity <- act
		),
		
		final	:	UML!ActivityFinalNode(
			activity <- act
		),
		fcf : UML!ControlFlow(
			name <- 'fromOpaqueActionToFinalNode',
			activity <- act,
			target <- final,
			source <- opaqueAction
		)	
}

--rule UnresolvedlabelStatement2StructuredActivity {
--	from
--		s : JAVA!UnresolvedLabeledStatement(
--			not s.getCorrespondingDec.oclIsKindOf(JAVA!LabeledStatement)
--		)
--	to
--		t	:	UML!StructuredActivityNode(
--			name <- 'UnresolvedLabeledStatement_' + s.refImmediateComposite().oclType().toString(),
--			inStructuredNode <- s.getCorrespondingDec.getStatement,
--			node <- Sequence{init, opaqueAction, final} ->flatten()						
--		),
--		
--		opaqueAction : UML!OpaqueAction(
--			name <- 'OpaqueAction_UnresolvedLabeledStatement',
--			inStructuredNode <- t
--		),
--		
--		init	:	UML!InitialNode(),
--		final	:	UML!ActivityFinalNode(),		
--		fcf : UML!ControlFlow(
--			name <- 'fromInitNodeToFinalNode', 
--			inStructuredNode <- t,
--			target <- final,
--			source <- opaqueAction
--		)
--}
