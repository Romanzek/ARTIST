/*
 * generated by Xtext
 */
package eu.artist.postmigration.nfrvt.lang.gml.validation

import eu.artist.postmigration.nfrvt.lang.common.eval.ExpressionValidator
import eu.artist.postmigration.nfrvt.lang.common.eval.util.ValueUtil
import eu.artist.postmigration.nfrvt.lang.gml.gml.AppliedQuantitativePropertyExpression
import eu.artist.postmigration.nfrvt.lang.gml.gml.CompositeGoal
import eu.artist.postmigration.nfrvt.lang.gml.gml.GmlPackage
import eu.artist.postmigration.nfrvt.lang.gml.gml.GoalReference
import eu.artist.postmigration.nfrvt.lang.gml.gml.HardGoal
import java.util.HashSet
import java.util.Set
import org.eclipse.xtext.validation.Check

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class GMLValidator extends AbstractGMLValidator {

	CompositeGoalValidator compositeGoalValidator = new CompositeGoalValidator();
	HardGoalValidator hardGoalConditionValidator = new HardGoalValidator();

	def showAll(ExpressionValidator validator) {
		validator.errors.forEach[msg, feature| error(msg, feature)]
		validator.warnings.forEach[msg, feature| warning(msg, feature)]
		validator.infos.forEach[msg, feature| info(msg, feature)]
		validator.reset
	}

	@Check
	def validCompositeGoalExpression(CompositeGoal goal) {
		val result = compositeGoalValidator.doEvaluate(goal.condition);
		compositeGoalValidator.showAll
		if(!ValueUtil.isBooleanOrNull(result))
			error("Condition does not return a boolean value.", GmlPackage.Literals.COMPOSITE_GOAL__CONDITION)
		val variableExpressions = goal.condition.eAllContents.filter(typeof(GoalReference)).toList
		if(ValueUtil.isBooleanOrNull(result) && variableExpressions.empty)
			warning("No references to any goals found, always returns " + ValueUtil.getBooleanOrNull(result) + ".", GmlPackage.Literals.COMPOSITE_GOAL__CONDITION)
	}
	
	@Check
	def validHardGoalCondition(HardGoal goal) {
		val result = hardGoalConditionValidator.doEvaluate(goal.condition);
		hardGoalConditionValidator.showAll
		if(!ValueUtil.isBooleanOrNull(result))
			error("Condition does not return a boolean value.", GmlPackage.Literals.HARD_GOAL__CONDITION)
		val variableExpressions = goal.condition.eAllContents.filter(typeof(AppliedQuantitativePropertyExpression)).toList
		if(ValueUtil.isBooleanOrNull(result) && variableExpressions.empty)
			warning("No $variables used in this condition, always returns " + ValueUtil.getBooleanOrNull(result) + ".", GmlPackage.Literals.HARD_GOAL__CONDITION)
	}
	
	@Check
	def infoAppliedProperty(AppliedQuantitativePropertyExpression exp) {
		info("Please make sure that " + exp.value.property.name + " has a compatible data type for the expression.", GmlPackage.Literals.APPLIED_QUANTITATIVE_PROPERTY_EXPRESSION__VALUE);
	}
	
	@Check
	def circularReferenceCompositeGoalExpression(CompositeGoal goal) {
		if(goal.checkCircle(new HashSet<CompositeGoal>()))
			error("Found circular reference in condition.", GmlPackage.Literals.COMPOSITE_GOAL__CONDITION)		
	}
	
	def boolean checkCircle(CompositeGoal goal, Set<CompositeGoal> foundGoals) {
		foundGoals.add(goal)
		val cgs = goal.goalReferences
		if(goal.condition instanceof GoalReference && (goal.condition as GoalReference).value instanceof CompositeGoal)
			cgs.add((goal.condition as GoalReference).value as CompositeGoal)
		val circle = cgs.filter[cg | foundGoals.contains(cg)]
		if(circle.empty) {
			foundGoals.addAll(cgs)
			var foundCircle = false
			for(cg : cgs) {
				foundCircle = cg.checkCircle(foundGoals)
				if(foundCircle) {
					return true
				}
			}
			return false
		}
		return true
	}
	
	def goalReferences(CompositeGoal goal) {
		return goal.condition.eAllContents.filter(typeof(GoalReference)).map[e | e.value].filter(typeof(CompositeGoal)).toSet
	}
}
